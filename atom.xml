<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lynette&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lynettez.github.io/"/>
  <updated>2020-02-05T14:08:08.902Z</updated>
  <id>http://lynettez.github.io/</id>
  
  <author>
    <name>Lynette Zhao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RNN Notes</title>
    <link href="http://lynettez.github.io/2020/02/05/RNN-Notes/"/>
    <id>http://lynettez.github.io/2020/02/05/RNN-Notes/</id>
    <published>2020-02-05T13:58:28.000Z</published>
    <updated>2020-02-05T14:08:08.902Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>摘自 《基于深度学习的自然语言处理》</p></blockquote><h2 id="简单RNN-S-RNN"><a href="#简单RNN-S-RNN" class="headerlink" title="简单RNN (S-RNN)"></a>简单RNN (S-RNN)</h2><p>对序列中元素顺序敏感的最简单的RNN形式称为Elman RNN或者简单RNN(S-RNN), S-RNN由Elman[1990]提出， 并由Mikolov[2012]用于探索在语言模型中的应用。<br>在其递归函数R里，状态s<sub>i-1</sub> 和输入x<sub>i</sub>分别线性变换， 结果相加(连同一个偏置项)， 然后通过一个非线性的激活函数g(通常是tanh或者ReLU)。确定性函数O：位置i的输出与这个未知的隐藏状态相同。<br>因为加入线性变换后跟随非线性变换的机制使得网络结构服与序列顺序敏感。实际上，S-RNN在序列标注问题以及语言模型上取得了很好的结果。</p><h2 id="门结构"><a href="#门结构" class="headerlink" title="门结构"></a>门结构</h2><p>因为梯度消失的问题，S-RNN很难有效地训练。误差信号(梯度)在反向传播过程中到达序列的后面部分是迅速减少，以至于无法到达先前的输入信号的位置，这导致S-RNN难以捕捉到长距离以来信息。因此，LTSM和GRU等基于门的结构被设计出来， 用以解决这一问题。</p><p>考虑将RNN视为一个通用的计算工具，其中的状态s<sub>i</sub>代表一个有限的记忆。每一种R函数的实现都会读入一个输入x<sub>i+1</sub>以及当前的记忆s<sub>i</sub>， 对它们进行某种操作，并将结果写入记忆得到新的记忆状态s<sub>i+1</sub>。从这种方式看来，S-RNN的一个明显的问题在于记忆的获取是不受控制的。在每一步的计算过程中，整个记忆状态都被读入，并且整个记忆状态也被改写。<br>那么如何一种更加受控的记忆读写方式？这是引入使用二进制门向量g控制记忆s的读写。这种门机制可以作为构建新RNN的基本模块：门向量能够控制记忆状态s的读写。然而门不应该是静态的，二应该是由当前的记忆状态和输入共同控制，并且应该从输入状态和记忆中进行学习，这就需要一个可微的门机制来支持学习的过程。<br>为了实现可微的门，我们允许g使用任意实数值，这个实数值随后通过一个sigmoid函数。将数值限定在(0,1)区间内，并且大多数只都在接近边界的位置，而接近0的那些下标则被阻拦。门的取值可以通话输入和目前的记忆来决定，并且能够通过使用基于梯度下降的方式来训练一个性能令人满意的网络。<br>受控的门机制是下面将要定义的LSTM和GRU的结构的基础：在每个时间片上，可微的门机制决定哪一部分记忆会被写入，以及哪一部分被覆盖(忘记)。这里相当抽象的描述将会在后续部分给出更直观的解释。</p><h3 id="长短期记忆网络-LSTM"><a href="#长短期记忆网络-LSTM" class="headerlink" title="长短期记忆网络(LSTM)"></a>长短期记忆网络(LSTM)</h3><p>LSTM(1997)被设计用于解决梯度消失的问题，并且是第一种引入门机制的结构。LSTM结构明确地将状态向量s<sub>i</sub>分解为两部分，一般称为“记忆单元”，另一半是运行记忆。记忆单元被设计用来保存跨时间的记忆以及梯度信息， 同时受控于可微门组件——模拟逻辑门的平滑数学函数。在每一个输入状态上，一个门被用来决定由多少新的输入加入记忆单元， 以及记忆单元中现有的多少记忆应该被忘记。<br>在训练LSTM网络的时候 Jozefowicz等人[2015]强烈建议将遗忘门的偏置项设置为接近1的值</p><h3 id="门限循环单元-GRU"><a href="#门限循环单元-GRU" class="headerlink" title="门限循环单元(GRU)"></a>门限循环单元(GRU)</h3><p>LSTM是一种很有效的结构，同时也十分复杂。结构的复杂性使得LSTM难以分析，同时计算代价也比较高，GRU[2014]是一种LSTM的替代方案，总体上它使用了更少的门并且没有单独的记忆组件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;摘自 《基于深度学习的自然语言处理》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;简单RNN-S-RNN&quot;&gt;&lt;a href=&quot;#简单RNN-S-RNN&quot; class=&quot;headerlink&quot; title=&quot;简单RNN (S-RNN)&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="DL" scheme="http://lynettez.github.io/categories/DL/"/>
    
    
  </entry>
  
  <entry>
    <title>DNN Training Notes</title>
    <link href="http://lynettez.github.io/2020/02/04/DNN-Training-Notes/"/>
    <id>http://lynettez.github.io/2020/02/04/DNN-Training-Notes/</id>
    <published>2020-02-04T03:14:18.000Z</published>
    <updated>2020-02-04T03:26:34.655Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>摘自 《基于深度学习的自然语言处理》</p></blockquote><h3 id="梯度消失与梯度爆炸"><a href="#梯度消失与梯度爆炸" class="headerlink" title="梯度消失与梯度爆炸"></a>梯度消失与梯度爆炸</h3><p>在深层网络中，因为梯度通过图反向传播回来，错误梯度是非常常见的， 要么梯度消失(变得非常接近0)，要么梯度爆炸(变得非常高)。在更深的网络中，这个问题变得更加严重，尤其是在递归和RNN中。处理梯度消失问题仍然是一个开放的研究问题。 解决办法有让网络变浅，逐步训练使用Batch-normalization方法，或者使用特定的结构去帮助梯度流动(如LSTM和GRU)。处理梯度爆炸有一个简单但是高效的办法：如果它们的范数超过给定的阈值就裁减掉。</p><hr><h3 id="饱和神经元和死神经元"><a href="#饱和神经元和死神经元" class="headerlink" title="饱和神经元和死神经元"></a>饱和神经元和死神经元</h3><p>带有tanh和sigmoid激活函数的网络层往往容易饱和—造成该层的输出都接近于1，这是激活函数的上界。饱和神经元具有很小的梯度，所以可以避免。带有ReLU激活函数的网络层不会饱和，但是会死掉—大部分甚至多有的值都是负值，因此对于所有的输入来说都裁剪为0，从而导致该层的梯度全为0。如果你的网络没有训练好，检查网络层的饱和神经元与死神经元是明智的。<br>饱和神经元是由值太大的输入层造成的。这可以通过更改初始化、缩放输入值的范围或者改变学习速率来控制。<br>死神经元是由进入网络层的负值引起的，减少学习率将减缓这种现象。<br>归一化是对抗饱和神经元的有效方法，但是在梯度计算过程中代价较大，一个相关的技巧为batch normalization。在计算机视觉中，BN已经成为深层网络训练一个关键的组成部分。在自然语言处理应用中， 它并没有那么受欢迎。</p><hr><h3 id="学习率"><a href="#学习率" class="headerlink" title="学习率"></a>学习率</h3><p>太大的学习率会阻止网络收敛到一个有效的解，太小的学习率则需要长时间来收敛。一个经验法则，实验应该从范围[0.1]内尝试初始学习率，比如0.001，0.01，0.1，1。观测网络的loss值， 一旦loss值在开发集上停止改进，则降低学习率。<br>学习率可以看做minibatch数量的函数。一个常见的表示是将初始速率除以迭代次数。</p><hr><h3 id="minibatch"><a href="#minibatch" class="headerlink" title="minibatch"></a>minibatch</h3><p>在每个训练样例(minibatch大小为1)或者每k个训练样例训练结束后更新参数。大的minibatch训练对有些问题是有益的。GPU对大的minibatch数据训练也有帮助，通过矩阵运算来取代矩阵向量运算。</p><p>Training时，计算梯度并存储在相应的参数中，再通过梯度进行参数更新</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;摘自 《基于深度学习的自然语言处理》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;梯度消失与梯度爆炸&quot;&gt;&lt;a href=&quot;#梯度消失与梯度爆炸&quot; class=&quot;headerlink&quot; title=&quot;梯度消失与梯度爆炸&quot;&gt;&lt;/a&gt;梯度消失与梯
      
    
    </summary>
    
      <category term="DL" scheme="http://lynettez.github.io/categories/DL/"/>
    
    
  </entry>
  
  <entry>
    <title>SEOUL</title>
    <link href="http://lynettez.github.io/2019/04/08/SEOUL/"/>
    <id>http://lynettez.github.io/2019/04/08/SEOUL/</id>
    <published>2019-04-08T12:00:41.000Z</published>
    <updated>2020-02-04T04:06:01.751Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>仁川机场，坐在我们对面的老夫妇，一边吃汉堡一边开心的聊天，老奶奶深灰色的头发蓬松的很好看，用过餐后老奶奶拿出粉饼和口红补好妆，牵着老爷爷的手走了。<br>我和同行的朋友 同时感叹了一句：好精致啊~</p></blockquote><p><img src="/amp-dist/sample/yinghua.jpg" alt="南山下的住宅"></p><hr><h3 id="购物篇"><a href="#购物篇" class="headerlink" title="购物篇"></a>购物篇</h3><p>我们这次因为时间有限，所以把所有时间都花在了shopping上，护肤品，彩妆，衣服，鞋子，面膜，奢饰品，小电器，IQOS，全部可以买到，除非你要买的是断货王。</p><p>购物一般不需要起早，明洞乐天免税店十一点才开门，建议先去十楼办张临时金卡，如果你真的去办了你会感谢我的:D</p><p><strong>护肤品，面膜</strong>，在乐天里折扣还是很可以的，我买的兰蔻安瓶倒是比新罗机场店贵一些，所以都不是绝对的，可以下载各大免税店的APP，提前查一下要买的东西，会变得更理智的，减少冲动消费的概率，用划算的价格买到想要的东西，真的会让人很开心(手动捂脸)</p><p>如果不买特别多特别沉的东西建议去<strong>机场免税店</strong>扫货，当然你要提前一些去机场，这样才有时间提货，扫货，仁川机场免税店的规模是北京T3的好几倍，因为新罗，新世界，乐天都在机场里，有的逛呢..</p><p><strong>鞋</strong>的话 做过攻略的都会知道一家韩国本土鞋店<em>SAPPUN</em>，他们家的鞋确实很好看，穿起来也很舒服，而且很便宜.. 弘大，林荫路都有店。弘大明洞还有很多专门卖运动鞋的大店，没有特别想要的款就不需要浪费时间在这里了。最后悔没有去逛New Balance，他们家新出的这款我超喜欢，后悔啊后悔<br><img src="/amp-dist/sample/newb.jpg" alt="New Balance"></p><p><strong>SJYP</strong>的小恐龙 还有购物袋也超好看 虽然不便宜但是买了之后超开心, 位置在林荫路，这里还有MLB和IQOS，MLB里面的T恤都超好看，逛江南真的不会像弘大和明洞那样到处都是人，很清静<br><img src="/amp-dist/sample/sjyp.jpg" alt="SJYP"></p><p>明洞地铁站在南山脚下，旁边就有一家很大的北面，后悔没有去 &gt;-&lt;</p><hr><h3 id="美食篇"><a href="#美食篇" class="headerlink" title="美食篇"></a>美食篇</h3><p>我们酒店在弘大，先给一个坐标：弘大入口站1号出口出右拐直走看到第一个十字路口，就是Line Friend店门口的路口，下面的美食都在这周边，<br><strong>白老师杂酱面(香港饭店0410)</strong>  味道很中肯，比国内好吃一倍吧，没有特别惊喜，海鲜面点的正常的，一点都不辣，汤超级好喝。<br><img src="/amp-dist/sample/zaz.jpg" alt="zazang"><br>Line Friend店对面有一家小小的CU便利店，可以买到李东旭的W茶和<strong>新西游记</strong>的玩偶造型的饮料，门口的路边摊里小鱼饼超级好吃！！！<br><img src="/amp-dist/sample/xinxiyou.jpg" alt="喜欢~"><br>附近的<strong>桥村炸鸡</strong>也是真的太太太好吃了，好想念那个味道，我们吃的有骨的炸全鸡，炸衣特别脆，鸡肉熟的刚刚好而且肉质很嫩， 凉了都好吃的炸鸡，真的跟望京的不一样！</p><p>还有就是十字路口附近的一家<strong>烤肉</strong>店，牛肉吃起来嫩嫩的香香的，冷面很细是我喜欢的细面，酱料也非常好吃，我们都被牛肉和冷面折服了，而且感觉被国内的韩餐深深的欺骗了，为什么国内的冷面这么粗。。<br><img src="/amp-dist/sample/bbq_lp.jpg" alt="好吃 炒鸡好吃"></p><p>还有<strong>弘大酱蟹</strong>，很有名的店，大众点评就可以搜到，注意他们家是一人选一个套餐，然后无限续添，不是一道菜一道菜的点，还有就是吃不了腥味的就不要浪费人家的肥蟹了，最后一句也是说给我们俩的听得，因为我们是有点吃不惯生的蟹和吓。。</p><p>下一站明洞，我们第一餐吃了<strong>章鱼锅和章鱼拌饭</strong>，活章鱼在锅里慢慢被煮熟。。有点残忍，但是，但是煮好之后的汤特别特别好喝..<br>第二餐是<strong>元祖南山王炸猪排</strong>，请回答1988里看他们吃炸猪排的时候，就在想象这个味道，结果真的是我想象的味道，巨好吃，每一桌上有一个铁盒，里面是萝卜块，配着猪排吃很解腻，真的超好吃！<br><img src="/amp-dist/sample/zp.jpg" alt="王猪排"></p><hr><p><img src="/amp-dist/sample/bbq.jpg" alt="想带妈妈去~"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;仁川机场，坐在我们对面的老夫妇，一边吃汉堡一边开心的聊天，老奶奶深灰色的头发蓬松的很好看，用过餐后老奶奶拿出粉饼和口红补好妆，牵着老爷爷的手走了。&lt;br&gt;我和同行的朋友 同时感叹了一句：好精致啊~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img
      
    
    </summary>
    
      <category term="Life Itself" scheme="http://lynettez.github.io/categories/Life-Itself/"/>
    
    
  </entry>
  
  <entry>
    <title>Phuket</title>
    <link href="http://lynettez.github.io/2019/03/14/Phuket/"/>
    <id>http://lynettez.github.io/2019/03/14/Phuket/</id>
    <published>2019-03-14T02:36:19.000Z</published>
    <updated>2020-02-04T04:05:12.145Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>飞机还没落地之前，路过笔直的海岸线，俯瞰蓝色的海水，白色的沙滩和棕色的小人儿，还有可以用灿烂来形容的阳光，一瞬间就把我200度的近视眼治愈了… 这就是我对普吉的第一印象。</p></blockquote><p><img src="/amp-dist/sample/sea.jpeg" alt="蓝色"></p><h3 id="Go-to-the-beach"><a href="#Go-to-the-beach" class="headerlink" title="Go to the beach!!"></a>Go to the beach!!</h3><p>想要完全进入放松状态，就去海滩!! 因为行程的原因，我们去了三个海滩</p><ul><li>Kamala Beach<br>离FantaSea主题公园比较近，周围民宿很多，海鲜烧烤也很多。</li></ul><p><img src="/amp-dist/sample/kamala.jpeg" alt="步行到kamala beach的小路上"><br><img src="/amp-dist/sample/kamala1.jpeg" alt="夜里的海浪"></p><ul><li>Patong Beach<br>离江西冷购物商场和夜市都不远， 外国人超级多，沙滩椅加太阳伞一共300B可以坐一整天，坐我们旁边的两个英国大爷好像每天都来，跟卖太阳镜的本地姐姐很熟，我不会游泳，坐在那里听着他们一直在聊家常和偶尔调情..<br>在大众点评上可以搜到附近的兰花餐厅评分还可以，但是实际去了也只是一般般，只有菠萝饭很好吃，重点其实是这家餐厅旁边可以租小摩托车，跟国内电动车一样加油刹车没有挂挡，护照压在他们那，我们租的是一天300B，在网上看到有免费租的，我们没遇到..</li></ul><p><img src="/amp-dist/sample/patong1.jpeg" alt="骑小摩托逛遍了Patong"></p><ul><li>还有是Thavorn Beach 度假村的海滩<br>这家度假村听说是欢乐颂在这取景了..不管它真假哈，里面的景色真的超级美，普吉岛鲜花很贵因为本地鲜花能养殖的很少，这家度假村主打的就是到处的鲜花像住在花园里一样，还有一个特色就是他们的海滨小屋，就是在海滩旁边的独户小屋，晚上可以看到好看的晚霞</li></ul><p><img src="/amp-dist/sample/huayuan.jpeg" alt="超美的晚霞"></p><hr><h3 id="不要去KingPower，不要去KingPower，-不要去KingPower"><a href="#不要去KingPower，不要去KingPower，-不要去KingPower" class="headerlink" title="不要去KingPower，不要去KingPower， 不要去KingPower"></a>不要去KingPower，不要去KingPower， 不要去KingPower</h3><blockquote><p>去王权免税店是这次旅行唯一的败笔，化妆品肯定没有北京T3的日上便宜吧，至少我们去的时候奢侈品也没有折扣，Cartier价钱跟国内差不多.. 其他本地食品和化妆品还比BigC贵！！<br>真的千万不要去王权， 购物在江西冷就足够了！因为它里面有BigC就够你买伴手礼和新鲜水果了，而且保证比王权便宜很多。<br>江西冷很大的 千万不要逛一栋就出来了，中间的小广场有家SPA也不错，电梯上去有中文菜单。<br>买药品的话Patong街上到处都是药店</p></blockquote><hr><h3 id="Patong夜市"><a href="#Patong夜市" class="headerlink" title="Patong夜市"></a>Patong夜市</h3><blockquote><p>香蕉饼不好吃，还不如在BigC买香蕉吃，炒饭炒河粉超级好吃。大龙虾最贵最好吃。：D<br>商贩的中文和英文说的也太好了吧~</p></blockquote><p><img src="/amp-dist/sample/lobster.jpeg" alt="sauce有点咸 正好配炒饭吃"></p><hr><h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><ul><li>榴梿确实比国内的多了一些新鲜的味道</li><li>多买一些芒果干，因为你回国之后吃着吃着就会后悔为什么不多买点</li><li>罗勒叶肉末味拌面真的太好吃了，千万不要买蓝色袋带动漫人物的方便面，亲测有点难吃</li><li>不要住Patong上面的Villa区，山路超级陡，出行不方便，texi来这都要多加钱</li><li>Banana防晒真的很好用，没必要买喷雾的，喷完千万不要穿白色的衣服</li><li>BigC，711，还有大部分店都可以用支付宝，但是刷支付宝比你在当地换现金贵一个点</li><li>防蚊虫的那个喷雾也超级好用 买了好多回来</li><li>我们只想去放松，所以没去景点玩，以后可能也不打算去景点，如果不怕累不怕晒黑的话可以尝试下潜水</li><li>一定学会了游泳再来，要不然面对蓝蓝的海和超级好看的泳池又下不了水 就像我一样太可惜了..</li><li>泰国航空的往返机票还是很便宜的 提前三个月买，我们两个人往返只花了4500RMB左右</li><li>普吉机场的东西是真的不便宜，化妆品特产什么的价格都相对贵一些，汉堡王的汉堡RMB要75一个..</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;飞机还没落地之前，路过笔直的海岸线，俯瞰蓝色的海水，白色的沙滩和棕色的小人儿，还有可以用灿烂来形容的阳光，一瞬间就把我200度的近视眼治愈了… 这就是我对普吉的第一印象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/amp-di
      
    
    </summary>
    
      <category term="Life Itself" scheme="http://lynettez.github.io/categories/Life-Itself/"/>
    
    
  </entry>
  
  <entry>
    <title>Start with a Wechat Mini Program</title>
    <link href="http://lynettez.github.io/2019/02/24/mini-gram/"/>
    <id>http://lynettez.github.io/2019/02/24/mini-gram/</id>
    <published>2019-02-24T02:33:32.000Z</published>
    <updated>2019-03-14T04:08:39.138Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Get-started"><a href="#Get-started" class="headerlink" title="Get started"></a>Get started</h3><blockquote><p>It’s quite easy to start developing a Wechat Mini Program following below tutotial. </p><ul><li><a href="https://developers.weixin.qq.com/miniprogram/dev/" target="_blank" rel="noopener">Developers.Wechat.Tutorial</a> - The official tutorial</li></ul></blockquote><p>If you do it right, you have the development tool and an Mini Program account for now. Let’s search for an mini program project you prefered on Github, and pull it into your local folder.<br>Open that project using the development tools with your own account it will ask for.</p><p>Now we need to know how it works with debugging and the official tutotial.</p><blockquote><p>As far as I known, some points you need to know firstly before you codes.</p></blockquote><ul><li><p>The app.json configuration is global to current Mini Program, which includes all of its page paths, permission you will added for userLocation or sth, and bottom tabBar you will provide a list of pages for it.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">app.json</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"pages"</span>: [</span><br><span class="line">        <span class="string">"pages/index/index"</span>,</span><br><span class="line">        ...</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"permission"</span>: &#123;</span><br><span class="line">      <span class="string">"scope.userLocation"</span>: &#123;</span><br><span class="line">        <span class="string">"desc"</span>: <span class="string">"你的位置信息将用于小程序位置接口的效果展示"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"window"</span>: &#123;</span><br><span class="line">        <span class="string">"backgroundTextStyle"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="string">"navigationBarBackgroundColor"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="string">"navigationBarTitleText"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="string">"navigationBarTextStyle"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="string">"enablePullDownRefresh"</span>: </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"tabBar"</span>: &#123;</span><br><span class="line">        <span class="string">"color"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="string">"selectedColor"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="string">"borderStyle"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="string">"backgroundColor"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="string">"list"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"pagePath"</span>: <span class="string">"pages/index/index"</span>,</span><br><span class="line">                <span class="string">"iconPath"</span>: <span class="string">""</span>,</span><br><span class="line">                <span class="string">"selectedIconPath"</span>: <span class="string">""</span>,</span><br><span class="line">                <span class="string">"text"</span>: <span class="string">""</span></span><br><span class="line">            &#125;,</span><br><span class="line">            ...</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>project.config.json is a config file for the whole project, it includes your appid(aka your mini program account), the project name and version. and so on.</p></li><li>page.json file is for every page we added as above pages/index/index, the pages/index is just the dictionary, there will be some files named index under that dic. The index.json is one of them, it useally used to name the page title. Btw, there also are files named index.js, index.wxml and index.wxss, thwy will be introduced as below.</li><li>.wxml file. WXML acts as the role of HTML. It’s used to add a view(image, button, swiper…) and the bind with related function in .js file.</li><li>.js file is a JS scripts used to process users’ operation on UI.</li><li>.wxss file possesses the majority of features of the CSS. In other words, it’s used to define some configuration of UI</li></ul><p><img src="/amp-dist/sample/wx.png" alt="Wechat Development Tool"></p><hr><h3 id="Using-API"><a href="#Using-API" class="headerlink" title="Using API"></a>Using API</h3><p>Here are many useful APIs and components provided by WeChat.</p><ul><li><a href="https://developers.weixin.qq.com/miniprogram/en/dev/api/index.html?t=19031116" target="_blank" rel="noopener">WX API</a></li><li><a href="https://developers.weixin.qq.com/miniprogram/en/dev/component/" target="_blank" rel="noopener">WX Components</a></li></ul><p>For my part, the map is very powerful to show a location marker and lead user to navigate it, and the API wx.showToast, wx.request and wx.makePhoneCall are very common to use.<br>It also includes many sample codes for each API, so we may go to the next part.</p><hr><h3 id="Cloud-Development-indtead-of-Backend-Server"><a href="#Cloud-Development-indtead-of-Backend-Server" class="headerlink" title="Cloud Development indtead of Backend Server"></a>Cloud Development indtead of Backend Server</h3><p>As we known, a backend server is usually in need if we want to load the data dynamically from a database，and it’s complicated to setup a backend server from nothing. I was depressed until I found the WeChat Cloud Development!</p><p>Currently the cloud base provided three basic capabilities:</p><ul><li>Cloud function: code running in the cloud, WeChat private protocol natural authentication, developers only need to write their own business logic code</li><li>Database: A JSON database that can be manipulated both in the front end of the applet and in the cloud function.</li><li>Storage: upload/download cloud files directly at the front end of the applet, visual management in the cloud development console</li></ul><p>The console is also easy to use, </p><ul><li>Click the button named “Cloud Development” in Wechat Development Tool.</li><li>Create enviroment with your own account for your project.</li><li>Add data set for your own database if you want to maintain a database</li><li>Using <a href="https://developers.weixin.qq.com/miniprogram/dev/wxcloud/guide/storage/api.html" target="_blank" rel="noopener">Wechat Cloud API</a> to do some operation for the database.</li></ul><p><img src="/amp-dist/sample/wxC.png" alt="Wechat Cloud Console"></p><hr><h3 id="Some-Links-you-may-need"><a href="#Some-Links-you-may-need" class="headerlink" title="Some Links you may need"></a>Some Links you may need</h3><pre><code>[Icons](https://www.flaticon.com/)[Pictures](http://588ku.com/)[Latitude and longitude for Map](http://api.map.baidu.com/lbsapi/getpoint/index.html)[How to get Music URL](https://blog.csdn.net/qq_38347669/article/details/81541845)</code></pre><blockquote><p>I’d like to thank the wechat team for the powerful framework here. Many thanks~<br>If you’re interested with my first mini program, you may scan below QR code or search “Wedding Invitation Lynettez” in Wechat.<br>Don’t be surprised, it is indeed an wedding invitation. :)</p></blockquote><p><img src="/amp-dist/sample/mywx.jpeg" alt="My First Mini Program"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Get-started&quot;&gt;&lt;a href=&quot;#Get-started&quot; class=&quot;headerlink&quot; title=&quot;Get started&quot;&gt;&lt;/a&gt;Get started&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;It’s quite easy to st
      
    
    </summary>
    
      <category term="Wechat Mini Program" scheme="http://lynettez.github.io/categories/Wechat-Mini-Program/"/>
    
    
  </entry>
  
  <entry>
    <title>Python coding style</title>
    <link href="http://lynettez.github.io/2019/01/20/Python-codestyle/"/>
    <id>http://lynettez.github.io/2019/01/20/Python-codestyle/</id>
    <published>2019-01-20T02:38:50.000Z</published>
    <updated>2019-03-14T02:45:03.136Z</updated>
    
    <content type="html"><![CDATA[<p>整份的PEP8指南在<a href="http://www.python.org/dev/peps/pep-0008" target="_blank" rel="noopener">这里</a></p><blockquote><p>为了自己能记下重点，和方便以后查找，在这里简单分享一下，一些Python coding时必须要遵守的规则。</p></blockquote><ul><li>每一层缩进用四个空格，而不用tab</li><li>每行字符不超过79</li><li>函数和类之间用两个空行隔开</li><li>在同一个类中每个方法之间用一个空行隔开</li><li>为变量赋值时，赋值符号左右两侧各写一个空格</li><li>函数，变量和属性应用小写，各单词间用下划线，eg. lowercase_underscore</li><li>受保护的实例属性，以单个下划线开头</li><li>私有的实例属性，以两个下划线开头</li><li>类和异常，以每个单词首字母大写的形式命名</li><li>模块级别的常量，全部用大写字母，各单词间加下划线</li><li>‘if a is not b‘ 是正确的格式，而不是‘if not a is b’</li><li>检查空值，用if not就够了</li><li>不要单行的if语句，for循环，while循环和except复合语句， 分开多行更清晰</li><li>import总是写在文件开头</li><li>import语句 顺序分三部分，先写标准库模块，之后是第三方模块，最后是自用模块，每个部分应按字母顺序排列</li></ul><blockquote><p>The zan of Python: 每件事都应该有直白的做法，而且最好只有一种。<br>以上内容摘自Brett Slatkin:《Effective Python: 59 Specific Ways to Write Better Python》</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;整份的PEP8指南在&lt;a href=&quot;http://www.python.org/dev/peps/pep-0008&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为了自己能记下重点，和方便以后查找，在
      
    
    </summary>
    
      <category term="Python" scheme="http://lynettez.github.io/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Python Json：Keep Entries Ordered</title>
    <link href="http://lynettez.github.io/2018/10/25/Python-JSON%EF%BC%9Akeep-entries-ordered/"/>
    <id>http://lynettez.github.io/2018/10/25/Python-JSON：keep-entries-ordered/</id>
    <published>2018-10-25T07:20:06.000Z</published>
    <updated>2018-10-28T01:31:09.335Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>If you want to maintain an ordered dictionary with json file in Python, this post might help.</p></blockquote><h3 id="1-Ordered-Dictionary"><a href="#1-Ordered-Dictionary" class="headerlink" title="1. Ordered Dictionary"></a>1. Ordered Dictionary</h3><p>As we known, Python dictionaries are unordered, but we got OrderedDict.</p><p>First of all, we have to use that to make sure the given dict is ordered.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from collections import OrderedDict</span><br><span class="line">givendict = OrderedDict()</span><br><span class="line">givendict[&quot;key1&quot;] = &quot;val1&quot;</span><br><span class="line">givendict[&quot;key2&quot;] = &quot;val2&quot;</span><br></pre></td></tr></table></figure></p><hr><h3 id="2-Json-dumps"><a href="#2-Json-dumps" class="headerlink" title="2. Json.dumps()"></a>2. Json.dumps()</h3><p>If we give the ordered dict to json.dumps() directly, the fields in that json file are still in the wrong order.<br>A simple way to preserving the order of a mappling in JSON is:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Json.dumps([givendict])</span><br></pre></td></tr></table></figure></p><p>The content of the json file will be like:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#123;&quot;key1&quot;: &quot;val1&quot;, &quot;key2&quot;: &quot;val2&quot;&#125;]</span><br></pre></td></tr></table></figure></p><hr><h3 id="3-Remove-from-the-json-file"><a href="#3-Remove-from-the-json-file" class="headerlink" title="3. Remove [] from the json file"></a>3. Remove [] from the json file</h3><p>When we tried to load the data from json file, we have to remove the “[]” firstly.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chars = &quot;[]&quot;</span><br><span class="line">for ch in chars：</span><br><span class="line">    if ch in data:</span><br><span class="line">        data = data.replace(ch, &quot;&quot;)</span><br></pre></td></tr></table></figure></p><hr><h3 id="4-Json-loads"><a href="#4-Json-loads" class="headerlink" title="4. Json.loads()"></a>4. Json.loads()</h3><p>Now it’s time to load the data, but the json.loads will still mess up order if you didn’t add the arg as below:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outordereddict = json.loads(data, object_pairs_hook=OrderedDict)</span><br></pre></td></tr></table></figure></p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;If you want to maintain an ordered dictionary with json file in Python, this post might help.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1-Or
      
    
    </summary>
    
      <category term="Python" scheme="http://lynettez.github.io/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Android Power Reset Reasons</title>
    <link href="http://lynettez.github.io/2018/07/17/Android-Power-Reset-Reasons/"/>
    <id>http://lynettez.github.io/2018/07/17/Android-Power-Reset-Reasons/</id>
    <published>2018-07-17T10:32:53.000Z</published>
    <updated>2018-07-25T07:50:26.381Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>解析bugreport，根据不同的log分析Android重启的原因</p></blockquote><h3 id="1-Normal-reset"><a href="#1-Normal-reset" class="headerlink" title="1. Normal reset"></a>1. Normal reset</h3><p>这种情况是最简单的，我们可以查看LAST_KMSG的最后一行，就可以得到相应的重启原因。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Restarting system with command: ***</span><br></pre></td></tr></table></figure></p><ul><li>如果为空，原因应为 adb reboot</li><li>如果是 bootloader， 原因应为 fastboot reboot</li><li>如果是其他明确的command， 可以按字面意思理解其原因</li></ul><h3 id="2-Random-reboot"><a href="#2-Random-reboot" class="headerlink" title="2. Random reboot"></a>2. Random reboot</h3><p>这种情况就是系统出错导致的重启。可以按一下四种情况去诊断其重启原因。<br>一般分为两个层面的重启，一种是hard reboot，一般是kernel 或者 radio-level的错误导致重启；另一种是在kernel正常运行的情况下Android runtime的重启，可能是由Deadlock，System server process crash或native crash导致的。</p><h4 id="2-1-Kernel-panic"><a href="#2-1-Kernel-panic" class="headerlink" title="2.1 Kernel panic"></a>2.1 Kernel panic</h4><p>诊断是否有kernel panic， 可以check kernel logs里是否有如下log<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[  424.909515] Kernel panic - not syncing: Fatal exception</span><br><span class="line">[  424.909606] Backtrace: </span><br><span class="line">[  424.909790] [&lt;c005a5ec&gt;] (dump_backtrace+0x0/0x10c) from [&lt;c05f38dc&gt;] (dump_stack+0x18/0x1c)</span><br><span class="line">[  424.909973]  r6:c5cccf00 r5:00000000 r4:c08505a0 r3:00000000</span><br></pre></td></tr></table></figure></p><h4 id="2-2-Radio-side-problem"><a href="#2-2-Radio-side-problem" class="headerlink" title="2.2 Radio-side problem"></a>2.2 Radio-side problem</h4><p>Radio level的错误可以查看LAST_KMSG中是否有如下log<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[  535.383270] ARM9 has CRASHED</span><br><span class="line">[  535.383666] smem: DIAG &apos;MOD SM-TM   00000</span><br></pre></td></tr></table></figure></p><h4 id="2-3-Deadlock"><a href="#2-3-Deadlock" class="headerlink" title="2.3 Deadlock"></a>2.3 Deadlock</h4><p>死锁的error log如下，可以从EVENT_LOG或者SYSTEM_LOG中查找。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">04-04 14:06:16.888   885  1089 W Watchdog: *** WATCHDOG KILLING SYSTEM PROCESS: null</span><br></pre></td></tr></table></figure></p><h4 id="2-4-System-server-process-crash"><a href="#2-4-System-server-process-crash" class="headerlink" title="2.4 System server process crash"></a>2.4 System server process crash</h4><p>log如下，也是从EVENT_LOG或者SYSTEM_LOG中查找。关键字：<br>*** FATAL EXCEPTION IN SYSTEM PROCESS</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">01-01 12:45:11.950 E/AndroidRuntime( 4429): *** FATAL EXCEPTION IN SYSTEM PROCESS: main</span><br></pre></td></tr></table></figure><h4 id="2-5-Native-crash"><a href="#2-5-Native-crash" class="headerlink" title="2.5 Native crash"></a>2.5 Native crash</h4><p>Native crash的log都是从一行星号开始, 可以作为标志去SYSTEM_LOG中查找。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">07-28 11:31:21.675: INFO/DEBUG(2880): *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***</span><br><span class="line">07-28 11:31:21.675: INFO/DEBUG(2880): Build fingerprint: &apos;verizon/voles/sholes/sholes:2.2.2/FRG83G/91102:user/release-keys&apos;</span><br><span class="line">07-28 11:31:21.675: INFO/DEBUG(2880): pid: 2893, tid: 2894  &gt;&gt;&gt; com.gnychis.coexisyst &lt;&lt;&lt;</span><br><span class="line">07-28 11:31:21.675: INFO/DEBUG(2880): signal 11 (SIGSEGV), fault addr 2d4eedb4</span><br><span class="line">07-28 11:31:21.675: INFO/DEBUG(2880):  r0 2d4eeda4  r1 00000000  r2 00000024  r3 00000000</span><br><span class="line">07-28 11:31:21.675: INFO/DEBUG(2880):  r4 00d3e770  r5 00000000  r6 4184ff98  r7 4184ffa4</span><br><span class="line">07-28 11:31:21.675: INFO/DEBUG(2880):  r8 100ffad0  r9 4184ff9c  10 4184ff84  fp 100ffe30</span><br><span class="line">07-28 11:31:21.675: INFO/DEBUG(2880):  ip 85b7efec  sp 100ffa88  lr 845d13f8  pc 845f8c38  cpsr 60000010</span><br><span class="line">07-28 11:31:21.675: INFO/DEBUG(2880):  d0  6472656767756265  d1  4472fb3844714069</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;解析bugreport，根据不同的log分析Android重启的原因&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1-Normal-reset&quot;&gt;&lt;a href=&quot;#1-Normal-reset&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="Android" scheme="http://lynettez.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>Analyze the Process of Setting KL for Physical Keyboard</title>
    <link href="http://lynettez.github.io/2018/07/15/Analyze-the-Process-of-Setting-KeyboardLayout-for-Physical-Keyboard/"/>
    <id>http://lynettez.github.io/2018/07/15/Analyze-the-Process-of-Setting-KeyboardLayout-for-Physical-Keyboard/</id>
    <published>2018-07-15T08:19:24.000Z</published>
    <updated>2018-07-25T07:44:22.866Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>基于Android 8.0源码，分析InputManagerService给Physical Keyboard 设置Keyboard Layout(KL)的具体过程。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">frameworks/<span class="keyword">native</span>/services/inputflinger/</span><br><span class="line">  - InputDispatcher.cpp</span><br><span class="line">  - InputReader.cpp</span><br><span class="line">  - InputManager.cpp</span><br><span class="line">  - EventHub.cpp</span><br><span class="line">  - InputListener.cpp</span><br><span class="line"></span><br><span class="line">frameworks/<span class="keyword">native</span>/libs/input/</span><br><span class="line">  - InputTransport.cpp</span><br><span class="line">  - Input.cpp</span><br><span class="line">  - InputDevice.cpp</span><br><span class="line">  - Keyboard.cpp</span><br><span class="line">  - KeyCharacterMap.cpp</span><br><span class="line">  - IInputFlinger.cpp</span><br><span class="line"></span><br><span class="line">frameworks/base/services/core/</span><br><span class="line">  - java/com/android/server/input/InputManagerService.java</span><br><span class="line">  - java/com/android/server/input/PersistentDataStore.java</span><br><span class="line">  - jni/com_android_server_input_InputManagerService.cpp</span><br><span class="line"></span><br><span class="line">frameworks/base/packages/InputDevices/</span><br><span class="line">  - src/com/android/inputdevices/InputDeviceReceiver.java</span><br><span class="line">  - res/xml/keyboard_layouts.xml</span><br><span class="line">  - res/raw/...</span><br></pre></td></tr></table></figure><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p><a href="http://gityuan.com/2016/12/10/input-manager/" target="_blank" rel="noopener">Gityuan博客</a>有详细分析Input系统，从该博客可以学习到Input模块的工作原理， 以及主要组成：</p><ul><li>Native层的InputReader负责从EventHub取出事件并处理，再交给InputDispatcher</li><li>Native层的InputDispatcher接收来自InputReader的输入事件，并记录WMS的窗口信息，用于派发事件到合适的窗口</li><li>Java层的InputManagerService跟WMS交互，WMS记录所有窗口信息，并同步更新到IMS，为InputDispatcher正确派发事件到ViewRootImpl提供保障</li></ul><p>当Physical Keyboard(后面会直接用PK代替) 通过USB与Android设备连接时，首先触发的是硬件驱动，UsbHostManager 识别PK并发出USB_DEVICE_ATTACHED广播, EventHub通过InputReader线程会循环读取消息并调用getEvents()读取输入事件。<br>调用的流程是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventHub::getEvents -&gt; EventHub::scanDevicesLocked -&gt; EventHub::scanDirLocked -&gt; EventHub::openDeviceLocked</span><br></pre></td></tr></table></figure></p><p>查看openDeviceLocked方法，可以知道此方法首先打开devicePath，然后new Device，调用LoadKeyMapLocked()来给PK load相应的.kl和.kcm, 所有的.kl文件和.kcm文件都放在/framework/base/data/keyboards/下面。我们可以看到有许多Vendor_XXXX_PRODUCT_XXXX命名的.kl和.kcm file，在loadKeymap时就是根据Device的vendor， product值来查找有没有相对应的Vendor_XXXX_PRODUCT_XXXX文件。多数情况下都不会有与PK对应的.kl和.kcm文件，这时Input系统会load默认的Generic.kl和Generic.kcm给该PK (Generic用的是qwerty layout)。</p><p>这也就是为什么有一些法语键盘或者德语键盘链接Android设备之后还是英语的layout的原因。<br>详细的调用流程可以看源码或者是<a href="https://blog.csdn.net/kc58236582/article/details/52199274" target="_blank" rel="noopener">这篇博文https://blog.csdn.net/kc58236582/</a>.</p><p>以上简单介绍了Input系统处理PK连接事件的过程和为其设置.kl和.kcm文件的过程。接下来我将详细介绍一下重新给PK设置Keyboard lauout的过程还有重载新的layout的过程。</p><h2 id="2-为PK重置kl"><a href="#2-为PK重置kl" class="headerlink" title="2. 为PK重置kl"></a>2. 为PK重置kl</h2><p>如上所述，当我们用到非英语键盘时，layout还会加载成qwert的，面对这个问题Input系统已经提供了相应的function供开发者调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/frameworks/base/services/java/com/android/server/input/InputManagerService.java</span><br><span class="line">    @Override</span><br><span class="line">    public void setKeyboardLayoutForInputDevice(InputDeviceIdentifier identifier,</span><br><span class="line">            InputMethodInfo imeInfo, InputMethodSubtype imeSubtype,</span><br><span class="line">            String keyboardLayoutDescriptor) &#123;</span><br><span class="line">        if (!checkCallingPermission(android.Manifest.permission.SET_KEYBOARD_LAYOUT,</span><br><span class="line">                &quot;setKeyboardLayoutForInputDevice()&quot;)) &#123;</span><br><span class="line">            throw new SecurityException(&quot;Requires SET_KEYBOARD_LAYOUT permission&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (keyboardLayoutDescriptor == null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;keyboardLayoutDescriptor must not be null&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (imeInfo == null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;imeInfo must not be null&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        InputMethodSubtypeHandle handle = new InputMethodSubtypeHandle(imeInfo, imeSubtype);</span><br><span class="line">        setKeyboardLayoutForInputDeviceInner(identifier, handle, keyboardLayoutDescriptor);</span><br><span class="line">    &#125;</span><br><span class="line">    private void setKeyboardLayoutForInputDeviceInner(InputDeviceIdentifier identifier,</span><br><span class="line">            InputMethodSubtypeHandle imeHandle, String keyboardLayoutDescriptor) &#123;</span><br><span class="line">        String key = getLayoutDescriptor(identifier);</span><br><span class="line">        synchronized (mDataStore) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (mDataStore.setKeyboardLayout(key, imeHandle, keyboardLayoutDescriptor)) &#123; (见2.2.1)</span><br><span class="line">                    if (DEBUG) &#123;</span><br><span class="line">                        Slog.d(TAG, &quot;Set keyboard layout &quot; + keyboardLayoutDescriptor +</span><br><span class="line">                                &quot; for subtype &quot; + imeHandle + &quot; and device &quot; + identifier +</span><br><span class="line">                                &quot; using key &quot; + key);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (imeHandle.equals(mCurrentImeHandle)) &#123;</span><br><span class="line">                        if (DEBUG) &#123;</span><br><span class="line">                            Slog.d(TAG, &quot;Layout for current subtype changed, switching layout&quot;);</span><br><span class="line">                        &#125;</span><br><span class="line">                        SomeArgs args = SomeArgs.obtain();</span><br><span class="line">                        args.arg1 = identifier;</span><br><span class="line">                        args.arg2 = imeHandle;</span><br><span class="line">                        mHandler.obtainMessage(MSG_SWITCH_KEYBOARD_LAYOUT, args).sendToTarget();（见2.2.3）</span><br><span class="line">                    &#125;</span><br><span class="line">                    mHandler.sendEmptyMessage(MSG_RELOAD_KEYBOARD_LAYOUTS);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                mDataStore.saveIfNeeded();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>此方法被用在<a href="http://androidxref.com/8.0.0_r4/xref/packages/apps/Settings/src/com/android/settings/inputmethod/KeyboardLayoutPickerFragment.java" target="_blank" rel="noopener">Settings/inputmethod</a>里.<br>下面我们分析Input系统是如何在底层运作的。</p><h3 id="2-1-InputDevices"><a href="#2-1-InputDevices" class="headerlink" title="2.1 InputDevices"></a>2.1 InputDevices</h3><h4 id="2-1-1-InputDeviceReceiver"><a href="#2-1-1-InputDeviceReceiver" class="headerlink" title="2.1.1 InputDeviceReceiver"></a>2.1.1 InputDeviceReceiver</h4><p>这个package维护的是一个接收“QUERY_KEYBOARD_LAYOUTS”的BroadcastReceiver。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/src/com/android/inputdevices/InputDeviceReceiver.java</span><br><span class="line">        &lt;receiver android:name=&quot;.InputDeviceReceiver&quot;</span><br><span class="line">                android:label=&quot;@string/keyboard_layouts_label&quot;&gt;</span><br><span class="line">            &lt;intent-filter&gt;</span><br><span class="line">                &lt;action android:name=&quot;android.hardware.input.action.QUERY_KEYBOARD_LAYOUTS&quot; /&gt;</span><br><span class="line">            &lt;/intent-filter&gt;</span><br><span class="line">            &lt;meta-data android:name=&quot;android.hardware.input.metadata.KEYBOARD_LAYOUTS&quot;</span><br><span class="line">                    android:resource=&quot;@xml/keyboard_layouts&quot; /&gt;</span><br><span class="line">        &lt;/receiver&gt;</span><br></pre></td></tr></table></figure></p><h4 id="2-1-2-Keyboardlayouts"><a href="#2-1-2-Keyboardlayouts" class="headerlink" title="2.1.2 Keyboardlayouts"></a>2.1.2 Keyboardlayouts</h4><p>这里还存放了重要的/res/xml/keyboardlayouts.xml 和 /res/raw/…kcm, /res/raw/下存放了所有语言的.kcm files. xml文件是map所有.kcm文件用的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;keyboard-layouts xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line">    &lt;keyboard-layout android:name=&quot;keyboard_layout_english_uk&quot;</span><br><span class="line">            android:label=&quot;@string/keyboard_layout_english_uk_label&quot;</span><br><span class="line">            android:keyboardLayout=&quot;@raw/keyboard_layout_english_uk&quot; /&gt;</span><br><span class="line">...</span><br><span class="line">    &lt;keyboard-layout android:name=&quot;keyboard_layout_latvian&quot;</span><br><span class="line">            android:label=&quot;@string/keyboard_layout_latvian&quot;</span><br><span class="line">            android:keyboardLayout=&quot;@raw/keyboard_layout_latvian_qwerty&quot; /&gt;</span><br><span class="line">&lt;/keyboard-layouts&gt;</span><br></pre></td></tr></table></figure></p><h3 id="2-2-InputManagerService"><a href="#2-2-InputManagerService" class="headerlink" title="2.2 InputManagerService"></a>2.2 InputManagerService</h3><p>此章节将介绍IMS中重要的方法和相应的Class。</p><h4 id="2-2-1-PersistentDataStore"><a href="#2-2-1-PersistentDataStore" class="headerlink" title="2.2.1 PersistentDataStore"></a>2.2.1 PersistentDataStore</h4><p>IMS通过PersistentDataStore来存储所有的Input devices的信息。在/data/system/input-manager-state.xml中。<br>通过adb可以查看该文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/data/system # cat input-manager-state.xml                                                                                                                      &lt;?xml version=&apos;1.0&apos; encoding=&apos;utf-8&apos; standalone=&apos;yes&apos; ?&gt;</span><br><span class="line">&lt;input-manager-state&gt;</span><br><span class="line">    &lt;input-devices&gt;</span><br><span class="line">        &lt;input-device descriptor=&quot;vendor:16700,product:8467&quot;&gt;</span><br><span class="line">            &lt;keyboard-layout descriptor=&quot;com.android.inputdevices/com.android.inputdevices.InputDeviceReceiver/keyboard_layout_french&quot; input-method-id=&quot;com.google.android.inputmethod.latin/com.android.inputmethod.latin.LatinIME&quot; input-method-subtype-id=&quot;843948332&quot; current=&quot;true&quot; /&gt;</span><br><span class="line">        &lt;/input-device&gt;</span><br><span class="line">        &lt;input-device descriptor=&quot;vendor:1266,product:1027&quot;&gt;</span><br><span class="line">            &lt;keyboard-layout descriptor=&quot;com.android.inputdevices/com.android.inputdevices.InputDeviceReceiver/keyboard_layout_french&quot; input-method-id=&quot;com.google.android.inputmethod.latin/com.android.inputmethod.latin.LatinIME&quot; input-method-subtype-id=&quot;-921088104&quot; current=&quot;true&quot; /&gt;</span><br><span class="line">        &lt;/input-device&gt;</span><br><span class="line">    &lt;/input-devices&gt;</span><br><span class="line">&lt;/input-manager-state&gt;</span><br></pre></td></tr></table></figure></p><p>我们可以看到其中com.android.inputdevices.InputDeviceReceiver/keyboard_layout_french就是对应着2.1.2中的Keyboard-layout name.</p><p>IMS.mDataStore就是PersistentDataStore的实例，以上IMS +1391行code就是在set相应的layout值。</p><h4 id="2-2-2-visitAllKeyboardLayouts"><a href="#2-2-2-visitAllKeyboardLayouts" class="headerlink" title="2.2.2 visitAllKeyboardLayouts()"></a>2.2.2 visitAllKeyboardLayouts()</h4><p>这个方法会被native层用到，之后的篇幅会介绍到。此方法主要功能就是遍历2.1.2中的keyboardlayouts.xml维护的所有的layouts。<br>还有另外一个方法是visitKeyboardLayout()会被Settings.getKeyboardLayout()用到，原理也是一样的，遍历xml找到相应的layout。<br>具体实现是如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void visitAllKeyboardLayouts(KeyboardLayoutVisitor visitor) &#123;</span><br><span class="line">    final PackageManager pm = mContext.getPackageManager();</span><br><span class="line">    Intent intent = new Intent(InputManager.ACTION_QUERY_KEYBOARD_LAYOUTS);</span><br><span class="line">    for (ResolveInfo resolveInfo : pm.queryBroadcastReceivers(intent,</span><br><span class="line">            PackageManager.GET_META_DATA | PackageManager.MATCH_DIRECT_BOOT_AWARE</span><br><span class="line">                    | PackageManager.MATCH_DIRECT_BOOT_UNAWARE)) &#123;</span><br><span class="line">        final ActivityInfo activityInfo = resolveInfo.activityInfo;</span><br><span class="line">        final int priority = resolveInfo.priority;</span><br><span class="line">        visitKeyboardLayoutsInPackage(pm, activityInfo, null, priority, visitor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中InputManager.ACTION_QUERY_KEYBOARD_LAYOUTS 就是2.1.1中的QUERY_KEYBOARD_LAYOUTS。</p><h4 id="2-2-3-handleSwithKeyboardLayout"><a href="#2-2-3-handleSwithKeyboardLayout" class="headerlink" title="2.2.3 handleSwithKeyboardLayout"></a>2.2.3 handleSwithKeyboardLayout</h4><p>此方法就是handle IMS +1404行的MSG_SWITCH_KEYBOARD_LAYOUT message。它主要做了两件事：</p><ul><li>mDataStore.switchKeyboardLayout, 将input-manager-state.xml更新为之前setKeyboardLayout(IMS +1391行)的值。</li><li>reloadKeyboardLayouts() -&gt; nativeReloadKeyboardLayouts() 见2.3.1</li></ul><h3 id="2-3-Native-InputManager"><a href="#2-3-Native-InputManager" class="headerlink" title="2.3 Native InputManager"></a>2.3 Native InputManager</h3><h4 id="2-3-1-nativeReloadKeyboardLayouts"><a href="#2-3-1-nativeReloadKeyboardLayouts" class="headerlink" title="2.3.1 nativeReloadKeyboardLayouts"></a>2.3.1 nativeReloadKeyboardLayouts</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp</span><br><span class="line">static void nativeReloadKeyboardLayouts(JNIEnv* /* env */,</span><br><span class="line">        jclass /* clazz */, jlong ptr) &#123;</span><br><span class="line">    NativeInputManager* im = reinterpret_cast&lt;NativeInputManager*&gt;(ptr);</span><br><span class="line"></span><br><span class="line">    im-&gt;getInputManager()-&gt;getReader()-&gt;requestRefreshConfiguration(</span><br><span class="line">            InputReaderConfiguration::CHANGE_KEYBOARD_LAYOUTS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要工作是trigger InputReader::requestRefreshConfiguration()</p><h4 id="2-3-2-InputReader-cpp"><a href="#2-3-2-InputReader-cpp" class="headerlink" title="2.3.2 InputReader.cpp"></a>2.3.2 InputReader.cpp</h4><p>gityuan的一篇<a href="http://gityuan.com/2016/12/11/input-reader/" target="_blank" rel="noopener">博客</a>中清晰地介绍了InputReader, 对理解下面的代码会很有帮助。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">void InputReader::requestRefreshConfiguration(uint32_t changes) &#123;</span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">    if (changes) &#123;</span><br><span class="line">        bool needWake = !mConfigurationChangesToRefresh;</span><br><span class="line">        mConfigurationChangesToRefresh |= changes;</span><br><span class="line"></span><br><span class="line">        if (needWake) &#123;</span><br><span class="line">            mEventHub-&gt;wake();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">void InputReader::loopOnce() &#123;</span><br><span class="line">    int32_t oldGeneration;</span><br><span class="line">    int32_t timeoutMillis;</span><br><span class="line">    bool inputDevicesChanged = false;</span><br><span class="line">    Vector&lt;InputDeviceInfo&gt; inputDevices;</span><br><span class="line">    &#123; // acquire lock</span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">        oldGeneration = mGeneration;</span><br><span class="line">        timeoutMillis = -1;</span><br><span class="line"></span><br><span class="line">        uint32_t changes = mConfigurationChangesToRefresh;</span><br><span class="line">        if (changes) &#123;</span><br><span class="line">            mConfigurationChangesToRefresh = 0;</span><br><span class="line">            timeoutMillis = 0;</span><br><span class="line">            refreshConfigurationLocked(changes);</span><br><span class="line">        &#125; else if (mNextTimeout != LLONG_MAX) &#123;</span><br><span class="line">            nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);</span><br><span class="line">            timeoutMillis = toMillisecondTimeoutDelay(now, mNextTimeout);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; // release lock</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">void InputReader::refreshConfigurationLocked(uint32_t changes) &#123;</span><br><span class="line">    mPolicy-&gt;getReaderConfiguration(&amp;mConfig);</span><br><span class="line">    mEventHub-&gt;setExcludedDevices(mConfig.excludedDeviceNames);</span><br><span class="line"></span><br><span class="line">    if (changes) &#123;</span><br><span class="line">...</span><br><span class="line">        if (changes &amp; InputReaderConfiguration::CHANGE_MUST_REOPEN) &#123;</span><br><span class="line">            mEventHub-&gt;requestReopenDevices();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (size_t i = 0; i &lt; mDevices.size(); i++) &#123;</span><br><span class="line">                InputDevice* device = mDevices.valueAt(i);</span><br><span class="line">                device-&gt;configure(now, &amp;mConfig, changes);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">void InputDevice::configure(nsecs_t when, const InputReaderConfiguration* config, uint32_t changes) &#123;</span><br><span class="line">...</span><br><span class="line">    if (!isIgnored()) &#123;</span><br><span class="line">        if (!changes) &#123; // first time only</span><br><span class="line">            mContext-&gt;getEventHub()-&gt;getConfiguration(mId, &amp;mConfiguration);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!changes || (changes &amp; InputReaderConfiguration::CHANGE_KEYBOARD_LAYOUTS)) &#123;</span><br><span class="line">            if (!(mClasses &amp; INPUT_DEVICE_CLASS_VIRTUAL)) &#123;</span><br><span class="line">                sp&lt;KeyCharacterMap&gt; keyboardLayout =</span><br><span class="line">                        mContext-&gt;getPolicy()-&gt;getKeyboardLayoutOverlay(mIdentifier); (见2.4)</span><br><span class="line">                if (mContext-&gt;getEventHub()-&gt;setKeyboardLayoutOverlay(mId, keyboardLayout)) &#123;</span><br><span class="line">                    bumpGeneration();（见2.5）</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这部分的代码主要工作是</p><ul><li>把InputReaderConfiguration::CHANGE_KEYBOARD_LAYOUTS换位给<br>mConfigurationChangesToRefresh</li><li>InputReader线程不停的loop，当mConfigurationChangesToRefresh不为0时，调用refreshConfigurationLocked方法</li><li>当changes值不为CHANGE_MUST_REOPEN时，将循环所有的InputDevice，并调用configure方法</li><li>当changes是CHANGE_KEYBOARD_LAYOUTS时 会调用两个重要的方法，将会再下两个小节详细介绍</li></ul><h3 id="2-4-getPolicy"><a href="#2-4-getPolicy" class="headerlink" title="2.4 getPolicy()"></a>2.4 getPolicy()</h3><p>如Gityuan博客中提到的，InputReader的成员变量mPolicy都是指NativeInputManager对象。这里getPolicy()得到的就是NativeInputManager对象。接下来我们看一下getKeyboardLayoutOverlay方法的具体工作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp</span><br><span class="line">public:</span><br><span class="line">    NativeInputManager(jobject contextObj, jobject serviceObj, const sp&lt;Looper&gt;&amp; looper);</span><br><span class="line">...</span><br><span class="line">    /* --- InputReaderPolicyInterface implementation --- */</span><br><span class="line">...</span><br><span class="line">    virtual sp&lt;KeyCharacterMap&gt; getKeyboardLayoutOverlay(const InputDeviceIdentifier&amp; identifier);</span><br><span class="line">...</span><br><span class="line">int register_android_server_InputManager(JNIEnv* env) &#123;</span><br><span class="line">    int res = jniRegisterNativeMethods(env, &quot;com/android/server/input/InputManagerService&quot;,</span><br><span class="line">            gInputManagerMethods, NELEM(gInputManagerMethods));</span><br><span class="line">    (void) res;  // Faked use when LOG_NDEBUG.</span><br><span class="line">    LOG_FATAL_IF(res &lt; 0, &quot;Unable to register native methods.&quot;);</span><br><span class="line"></span><br><span class="line">    // Callbacks</span><br><span class="line"></span><br><span class="line">    jclass clazz;</span><br><span class="line">    FIND_CLASS(clazz, &quot;com/android/server/input/InputManagerService&quot;);</span><br><span class="line">...</span><br><span class="line">    GET_METHOD_ID(gServiceClassInfo.getKeyboardLayoutOverlay, clazz,</span><br><span class="line">            &quot;getKeyboardLayoutOverlay&quot;,</span><br><span class="line">            &quot;(Landroid/hardware/input/InputDeviceIdentifier;)[Ljava/lang/String;&quot;);</span><br></pre></td></tr></table></figure></p><p>主要工作就是通过JNI调用JAVA层的InputManagerService.getKeyboardLayoutOverlay()方法。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">    // Native callback.</span><br><span class="line">    private String[] getKeyboardLayoutOverlay(InputDeviceIdentifier identifier) &#123;</span><br><span class="line">        if (!mSystemReady) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String keyboardLayoutDescriptor = getCurrentKeyboardLayoutForInputDevice(identifier);</span><br><span class="line">        if (keyboardLayoutDescriptor == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final String[] result = new String[2];</span><br><span class="line">        visitKeyboardLayout(keyboardLayoutDescriptor, new KeyboardLayoutVisitor() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void visitKeyboardLayout(Resources resources,</span><br><span class="line">                    int keyboardLayoutResId, KeyboardLayout layout) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    result[0] = layout.getDescriptor();</span><br><span class="line">                    result[1] = Streams.readFully(new InputStreamReader(</span><br><span class="line">                            resources.openRawResource(keyboardLayoutResId)));</span><br><span class="line">                &#125; catch (IOException ex) &#123;</span><br><span class="line">                &#125; catch (NotFoundException ex) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>可以看到它的主要工作是</p><ul><li>从InputDeviceIdentifier中拿到keyboardLayoutDescriptor</li><li>调用visitKeyboardLayout()去遍历kayboardlayouts.xml找到对应的layout resource文件并返回。见2.2.2。</li></ul><h3 id="2-5-EventHub-setKeyboardLayoutOverlay"><a href="#2-5-EventHub-setKeyboardLayoutOverlay" class="headerlink" title="2.5 EventHub::setKeyboardLayoutOverlay()"></a>2.5 EventHub::setKeyboardLayoutOverlay()</h3><p>从2.4节得到的keyboardlayout result作为参数，通过EventHub设置给相应的Device。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">bool EventHub::setKeyboardLayoutOverlay(int32_t deviceId,</span><br><span class="line">        const sp&lt;KeyCharacterMap&gt;&amp; map) &#123;</span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line">    Device* device = getDeviceLocked(deviceId);</span><br><span class="line">    if (device) &#123;</span><br><span class="line">        if (map != device-&gt;overlayKeyMap) &#123;</span><br><span class="line">            device-&gt;overlayKeyMap = map;</span><br><span class="line">            device-&gt;combinedKeyMap = KeyCharacterMap::combine(</span><br><span class="line">                    device-&gt;keyMap.keyCharacterMap, map);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最终实现为PK设置非英语的keyboard layout。</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>Native callback 感觉是最有意思的地方，以后可以用一下，JNI层还是需要多加研究的。对于Input系统，算是通过这次机会了解到这么多细节的东西，但是还有InputDispatch的部分还需要日后仔细学习。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;基于Android 8.0源码，分析InputManagerService给Physical Keyboard 设置Keyboard Layout(KL)的具体过程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlig
      
    
    </summary>
    
      <category term="Android" scheme="http://lynettez.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>Android VTS V8.0</title>
    <link href="http://lynettez.github.io/2018/06/30/Android-VTS-V8-0/"/>
    <id>http://lynettez.github.io/2018/06/30/Android-VTS-V8-0/</id>
    <published>2018-06-30T00:43:45.000Z</published>
    <updated>2018-07-03T02:38:06.993Z</updated>
    
    <content type="html"><![CDATA[<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>Android Vendor Test Suite 包含三部分： VTS， VTS-*， VTI</p><p><em>VTS</em></p><blockquote><p>VTS 是Android Vendor 接口的一致性测试套件， Android Vendor接口即VINTF， 它相应的Object Data 被定义在device manifest 中. Refer to VINTF Object Data Link</p></blockquote><p><em>VTS-</em> *</p><blockquote><p>VTS- 包括可选的非功能测试和测试用例开发工具。<br>VTS 和 VTS- 有一组测试用例， 用于直接在VINTF下测试一下组件：<br>HAL modules，Vendor native libraries(e.g., Vendor NDK. shortly VNDK), OS (i.e., Linux kernel)</p></blockquote><p><em>VTI</em></p><blockquote><p>Vendor Test Infrastructure(VTI) 是一套基于云的基础框架，作用是允许Android设备合作伙伴可以轻松创建一个基于云的持续的VTS测试集成服务。</p></blockquote><hr><h3 id="编译和运行一个VTS-Test-Plan"><a href="#编译和运行一个VTS-Test-Plan" class="headerlink" title="编译和运行一个VTS Test Plan"></a>编译和运行一个VTS Test Plan</h3><p><em>搭建测试环境</em></p><ul><li>64-bit Ubuntu Linux</li><li>Java 8</li><li>Python 2.7</li><li>ADB 1.0.39 adb 一定要 必须要更新 link</li></ul><p>下面下载项，<strong> 一个都不要缺</strong>！！</p><p>Python development kit：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python-dev</span><br></pre></td></tr></table></figure><p>Protocol Buffer tools：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python-protobuf</span><br><span class="line">sudo apt-get install protobuf-compiler</span><br></pre></td></tr></table></figure><p>Python virtual environment-related tools:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python-virtualenv</span><br><span class="line">sudo apt-get install python-pip</span><br></pre></td></tr></table></figure><p>并且要确保linux主机可以用过adb shell 连接到你的Android测试设备</p><p>完成以上工作就可以 编译 VTS 包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">. build/envsetup.sh</span><br><span class="line">lunch aosp_arm64-userdebug</span><br><span class="line">make vts -j</span><br></pre></td></tr></table></figure></p><p>如果你有整套的Android 源码，可以直接croot下运行make vts</p><p>运行 VTS 测试：<br>进入你make出的out 路径并解压，就可以得到一个可执行文件 vts-tradefed。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vts-tradefed</span><br><span class="line">run vts     // where vts is the test plan name</span><br></pre></td></tr></table></figure></p><p>常用的命令：</p><ul><li>run vts //运行默认的vts测试项</li><li>run vts-hal //运行默认的vts hal测试项</li><li>run vts-kernel //运行默认的vts kernel 测试项</li><li>run vts -m &lt;测试模块&gt; //运行特殊的测试模块</li><li>run vts -s &lt;设备串口&gt; //连接多设备时使用</li></ul><p>Windows 下运行VTS测试， 可参考<a href="https://codelabs.developers.google.com/codelabs/android-vts/#1" target="_blank" rel="noopener">Link</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;组成&quot;&gt;&lt;a href=&quot;#组成&quot; class=&quot;headerlink&quot; title=&quot;组成&quot;&gt;&lt;/a&gt;组成&lt;/h3&gt;&lt;p&gt;Android Vendor Test Suite 包含三部分： VTS， VTS-*， VTI&lt;/p&gt;
&lt;p&gt;&lt;em&gt;VTS&lt;/em&gt;&lt;/
      
    
    </summary>
    
      <category term="Android" scheme="http://lynettez.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>冥想练习</title>
    <link href="http://lynettez.github.io/2018/06/30/%E5%86%A5%E6%83%B3%E7%BB%83%E4%B9%A0/"/>
    <id>http://lynettez.github.io/2018/06/30/冥想练习/</id>
    <published>2018-06-30T00:31:21.000Z</published>
    <updated>2018-07-03T02:38:30.008Z</updated>
    
    <content type="html"><![CDATA[<p>Meditate 冥想<br>没有任何宗教的概念，提升幸福感的一种好的方式。</p><hr><p>我们的意识，每天都在不停的思考，做出反应，提出计划，给出判断，还会有不切实际的幻想，对未知未来的联想， 等等… 作为普通人的我们，除了生理疼痛的时候，很少会把意识集中在自己身上，很少去观察现在这个时候的自己。如果我们把感知放大，去感受当下真实发生的让人开心的事情，你就会发现，我们的小确幸才是我们已经得到的真实的宝藏。</p><p>冥想就是让人感受当下真实的美好， 抓住真实的幸福。<br>尝试过冥想的同学一定会感受到，我们的思维真的很难控制，很难专心的感受呼吸，或者专心的去想那根蜡烛，思绪一定会调皮的想着一会吃什么，或者回忆与某人的对话，等等…</p><p>冥想其实也可以让我们练习如何专注于一件事，这就是为什么有些提高注意力的课程会教你如何冥想的原因。个人感觉确实有点效果，真实的体验，之前coding的时候必须要听一些很嗨的rap，越嗨越有劲头，现在真的会觉得吵了… 只好选择一些轻音乐，之前从来都不会听的轻音乐…</p><p>说到这里 想推荐大家 Calm , 有网页版的，也有app。没有特殊需要就不用花钱买课程，用facebook login之后，就可以在首页选择不同的背景，每个动态背景&gt;都配有相应的声音或者轻音乐。比如海浪声，下雨声， 烧柴声，我自己真的超享受。各种ASMR，一定有一个是你自己的ASMR。</p><p>决定要冥想， 但不知道如何正确的冥想，建议先读：<strong> 初学者的冥想书</strong> by Kornfield J. 我是边学习边调整的，相信只要每天坚持就一定有所收获</p><p>下面算是这本书的提炼，主要是把当时觉得很有帮助的point列出来，方便回顾。</p><hr><ul><li>冥想练习有很多种，选择最适合你的，有助于你发展对内心，意识，身体和感受的察觉，才是最好的冥想练习</li><li>作出选择之后，重在坚持，坚持每天冥想，选择你最喜欢的清晨或者傍晚，坚持静坐十五分钟或者你喜欢的时间长短</li><li>所有事物都处在变化的过程中，不妨跟随这种改变，接纳事物的不确定性。在冥想中学者去理解并信任无常的法则</li><li>冥想是为了洞悉生命的法则。在冥想中，我们不断将注意力从奔腾不息的思维和念头上拉回，转而放在身体与感觉之上</li></ul><hr><h3 id="冥想练习之-观呼吸"><a href="#冥想练习之-观呼吸" class="headerlink" title="冥想练习之 观呼吸"></a>冥想练习之 观呼吸</h3><ul><li>首先，找一个你觉得安稳，舒服，放松的姿势，没有压力的坐直，端庄一些，但无需苛求自己</li><li>微微沉肩，让手臂自然下垂，手垂在衣服下摆或膝盖上，保持脊背挺直的同时又能放松</li><li>若哪里不舒服，活动一下也无妨；闭上眼睛，或微微张开 看着地板即可</li><li>将注意力带到此刻，留心周围的环境和声音，去察觉你的身体有什么感受</li><li>观呼吸引导我们察觉呼吸正在发生这一事实，体验自然的呼吸，初期会感觉呼吸变得很紧，很不自然，这很常见，只要放轻松，如果还有紧迫感存在，不妨轻轻松松的面对它</li><li>在静坐初期，心念会如瀑布，你能做的就是，一旦察觉自己陷入思考，计划或回忆中，就给这个念头起个名字“计划”，“回忆”… 并任这个念头离开，回到呼吸上</li><li>要记得心念总是偏离呼吸到别的事情上是非常常见的，不必评判自己这样做不对，只要抹去念头回到呼吸上即可</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Meditate 冥想&lt;br&gt;没有任何宗教的概念，提升幸福感的一种好的方式。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;我们的意识，每天都在不停的思考，做出反应，提出计划，给出判断，还会有不切实际的幻想，对未知未来的联想， 等等… 作为普通人的我们，除了生理疼痛的时候，很少会把意识集中在自己
      
    
    </summary>
    
      <category term="Life Itself" scheme="http://lynettez.github.io/categories/Life-Itself/"/>
    
    
  </entry>
  
  <entry>
    <title>Android HIDL (Java)</title>
    <link href="http://lynettez.github.io/2018/06/18/Android-HIDL-Java/"/>
    <id>http://lynettez.github.io/2018/06/18/Android-HIDL-Java/</id>
    <published>2018-06-18T04:20:33.000Z</published>
    <updated>2018-07-03T02:50:13.862Z</updated>
    
    <content type="html"><![CDATA[<pre><code>HAL接口定义语言或HIDL（发音为“hide-l”）是一种接口描述语言（IDL），用于指定HAL与其用户之间的接口。 它允许指定类型和方法调用，并将其收集到接口和包中。 更广泛地说，HIDL是可以独立编译的代码库之间进行通信的系统。HIDL旨在用于进程间通信（IPC）。</code></pre><p>以上是来自Android官方文档。学习或者尝试使用过HIDL的coder一定都看过<a href="https://source.android.google.cn/devices/architecture/hidl/" target="_blank" rel="noopener">Android HIDL</a>，所以都会了解到，定义了HIDL接口之后，我们可以用C++和JAVA两种方式去写HIDL接口的实现，大多数的HIDL接口都会用C++去写接口的具体实现，并通过.rc文件来start接口服务，这种实现方式很通用，官网和许多博客有具体介绍，如果你需要在native层写接口实现，那可以移步google去搜索一下。</p><p>而JAVA实现方式，一是官网没有特别具体的介绍，二是很少有这种需求也很少有博主用过这种方式，而我在工作中恰好有这样一个需求：  就是要通过HIDL的JAVA实现server端，从而把Android framework的API暴露给native层。<br>经过一番尝试终于实现了需求，所以想要通过这篇博文记录一下自己的收获和实现过程中遇到的问题。</p><hr><h3 id="定义接口文件"><a href="#定义接口文件" class="headerlink" title="定义接口文件"></a>定义接口文件</h3><p>首先根据官方文档提供的格式写好自己的.hal接口文件，并通过hild-gen生成相应的Android.bp 和 Android.mk文件。<br>两个文件会相应build出很重要的C++和JAVA的Shared Library，这两个库是供服务端和客户算使用的。</p><ul><li>这里我曾遇到的问题是Android.bp有问题，build不出相应的C++的Shared Library。<ul><li>解决办法是修改/interfaces/下面的所有Android.bp，确保他们都加了你的新接口的路径（eg. myinterface/1.0），只要有一层缺了该路径，就会导致build不出你要的C++ Library.</li></ul></li></ul><p>如果运行hile-gen时，显示error找不到command， 需要先在/system/tools/下 运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m hidl-gen</span><br></pre></td></tr></table></figure><hr><h3 id="JAVA-接口的实现"><a href="#JAVA-接口的实现" class="headerlink" title="JAVA 接口的实现"></a>JAVA 接口的实现</h3><p>用JAVA实现接口，有点类似于AIDL的借口实现，我们需要实现一个服务端apk，并在Android开机启动时保证成功调起接口的服务，以便各个客户端使用。</p><ul><li>首先有了相应的.bp和.mk文件，就可以得到相应的C++ 和 JAVA的Library，我们需要在JAVA server apk 的makefile 中引入Java library，</li><li><p>其次，server端必须要有一个一直在运行的进程在，所以我们需要一个activity或者service进程来承载整个server端，并且需要在监听到开机广播后启用它，并完成工作：registerAsService() //让我们定义的接口的HwService注册到HwServiceManager中</p><ul><li><p>类似于AIDL，我们同样需要实现类MyInterface extends IMyInterface.Stub，之后Override所有接口方法并实现具体的function。下面是registerAsService()具体例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyInterface testService = <span class="keyword">new</span> MyInterface();</span><br><span class="line">testService.registerAsService(<span class="string">"MyTestService"</span>);</span><br></pre></td></tr></table></figure></li><li><p>这里遇到过的问题是Service注册之后 client端偶尔会得到空的Service。因为当时只是试验，所以就随意的在service.onStartCommand()中加了上面两行代码。 解决办法就是要把MyInterface的对象作为Service的成员变量，这样就不会偶尔被回收了…</p></li></ul></li><li><p>第三，修改 DEVICE MANIFEST 和 SELINUX POLICY。只有修改过这两项，你的service才允许被注册到HwServiceManager中。Device Manifest 可以参考 <a href="https://source.android.google.cn/devices/architecture/vintf/objects" target="_blank" rel="noopener">VINTF Object Data Link</a>用相同的格式声明你自己的接口。如果你用C++实现server端这一条同样需要被执。</p><ul><li>关于SELinux 就不具体介绍了，可以根据相应的SELinux denial logs来修改你的SELinux policy。在这之前可以用下面的命令行跳过SELinux 的拦截。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell setenforce 0</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h3 id="CLIENT-端测试"><a href="#CLIENT-端测试" class="headerlink" title="CLIENT 端测试"></a>CLIENT 端测试</h3><p>Client端不区分JAVA实现的还是C++实现的接口。Client端实现很简单，算是HIDL的优点之一，只要调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IMyInterface.getService(<span class="string">"MyTestService"</span>) <span class="comment">//JAVA</span></span><br><span class="line">IMyInterface::getService(<span class="string">"MyTestService"</span>) <span class="comment">//C++</span></span><br></pre></td></tr></table></figure><p>JAVA Client端同时也需要引用JAVA Library。如果有相应的Callback， 需要像AIDL一样在Client端有一个Callback类 extends ICallback.Stub.</p><p>C++ 的Client端 同样的需要加C++的Shared Library.</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过HIDL JAVA server端封装某些framework API，native层就可以通过HIDL接口调用相应的方法，从而调用到framework API了，除了缩短升级时间的优点，就这一个功能也是非常有用的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;HAL接口定义语言或HIDL（发音为“hide-l”）是一种接口描述语言（IDL），用于指定HAL与其用户之间的接口。 它允许指定类型和方法调用，并将其收集到接口和包中。 更广泛地说，HIDL是可以独立编译的代码库之间进行通信的系统。
HIDL旨在用于进程间
      
    
    </summary>
    
      <category term="Android" scheme="http://lynettez.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>Start with Hexo</title>
    <link href="http://lynettez.github.io/2018/06/18/Start-with-Hexo/"/>
    <id>http://lynettez.github.io/2018/06/18/Start-with-Hexo/</id>
    <published>2018-06-18T03:12:25.000Z</published>
    <updated>2018-06-18T04:16:16.762Z</updated>
    
    <content type="html"><![CDATA[<p>Some links which could help us to create our own site:</p><p><a href="https://guides.github.com/features/pages/" target="_blank" rel="noopener">How to creat your GitHub Pages</a></p><p><a href="https://hexo.io/zh-tw/docs/index.html" target="_blank" rel="noopener">Hexo Guide</a></p><p><a href="https://www.jianshu.com/p/21d80d5bfca1" target="_blank" rel="noopener">Hexo deployer to your GitHub Pages</a></p><p><a href="https://wizardforcel.gitbooks.io/markdown-simple-world/1.html" target="_blank" rel="noopener">Markdown 编辑器推荐</a></p><p><a href="https://www.jianshu.com/p/c4f65ebe23ad" target="_blank" rel="noopener">Add Disqus comments in Hexo</a></p><hr><p>Commonly used commands:</p><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;My New Post&quot;</span><br></pre></td></tr></table></figure><p>More info: New a post and need you to modify the .md file</p><h3 id="Clean-project"><a href="#Clean-project" class="headerlink" title="Clean project"></a>Clean project</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure><p>More info: Clean some files which was generated by the last operate</p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><p>More info: Generating</p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>More info: test in local</p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>Don’t forget to fork your repo after hexo d</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Some links which could help us to create our own site:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://guides.github.com/features/pages/&quot; target=&quot;_blank&quot; rel=&quot;no
      
    
    </summary>
    
      <category term="Hexo" scheme="http://lynettez.github.io/categories/Hexo/"/>
    
    
  </entry>
  
</feed>
