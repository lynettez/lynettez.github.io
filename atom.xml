<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lynette&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lynettez.github.io/"/>
  <updated>2018-10-28T01:31:09.335Z</updated>
  <id>http://lynettez.github.io/</id>
  
  <author>
    <name>Lynette Zhao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python Json：Keep Entries Ordered</title>
    <link href="http://lynettez.github.io/2018/10/25/Python-JSON%EF%BC%9Akeep-entries-ordered/"/>
    <id>http://lynettez.github.io/2018/10/25/Python-JSON：keep-entries-ordered/</id>
    <published>2018-10-25T07:20:06.000Z</published>
    <updated>2018-10-28T01:31:09.335Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>If you want to maintain an ordered dictionary with json file in Python, this post might help.</p></blockquote><h3 id="1-Ordered-Dictionary"><a href="#1-Ordered-Dictionary" class="headerlink" title="1. Ordered Dictionary"></a>1. Ordered Dictionary</h3><p>As we known, Python dictionaries are unordered, but we got OrderedDict.</p><p>First of all, we have to use that to make sure the given dict is ordered.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from collections import OrderedDict</span><br><span class="line">givendict = OrderedDict()</span><br><span class="line">givendict[&quot;key1&quot;] = &quot;val1&quot;</span><br><span class="line">givendict[&quot;key2&quot;] = &quot;val2&quot;</span><br></pre></td></tr></table></figure></p><hr><h3 id="2-Json-dumps"><a href="#2-Json-dumps" class="headerlink" title="2. Json.dumps()"></a>2. Json.dumps()</h3><p>If we give the ordered dict to json.dumps() directly, the fields in that json file are still in the wrong order.<br>A simple way to preserving the order of a mappling in JSON is:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Json.dumps([givendict])</span><br></pre></td></tr></table></figure></p><p>The content of the json file will be like:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#123;&quot;key1&quot;: &quot;val1&quot;, &quot;key2&quot;: &quot;val2&quot;&#125;]</span><br></pre></td></tr></table></figure></p><hr><h3 id="3-Remove-from-the-json-file"><a href="#3-Remove-from-the-json-file" class="headerlink" title="3. Remove [] from the json file"></a>3. Remove [] from the json file</h3><p>When we tried to load the data from json file, we have to remove the “[]” firstly.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chars = &quot;[]&quot;</span><br><span class="line">for ch in chars：</span><br><span class="line">    if ch in data:</span><br><span class="line">        data = data.replace(ch, &quot;&quot;)</span><br></pre></td></tr></table></figure></p><hr><h3 id="4-Json-loads"><a href="#4-Json-loads" class="headerlink" title="4. Json.loads()"></a>4. Json.loads()</h3><p>Now it’s time to load the data, but the json.loads will still mess up order if you didn’t add the arg as below:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outordereddict = json.loads(data, object_pairs_hook=OrderedDict)</span><br></pre></td></tr></table></figure></p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;If you want to maintain an ordered dictionary with json file in Python, this post might help.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1-Or
      
    
    </summary>
    
      <category term="Python" scheme="http://lynettez.github.io/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Android Power Reset Reasons</title>
    <link href="http://lynettez.github.io/2018/07/17/Android-Power-Reset-Reasons/"/>
    <id>http://lynettez.github.io/2018/07/17/Android-Power-Reset-Reasons/</id>
    <published>2018-07-17T10:32:53.000Z</published>
    <updated>2018-07-25T07:50:26.381Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>解析bugreport，根据不同的log分析Android重启的原因</p></blockquote><h3 id="1-Normal-reset"><a href="#1-Normal-reset" class="headerlink" title="1. Normal reset"></a>1. Normal reset</h3><p>这种情况是最简单的，我们可以查看LAST_KMSG的最后一行，就可以得到相应的重启原因。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Restarting system with command: ***</span><br></pre></td></tr></table></figure></p><ul><li>如果为空，原因应为 adb reboot</li><li>如果是 bootloader， 原因应为 fastboot reboot</li><li>如果是其他明确的command， 可以按字面意思理解其原因</li></ul><h3 id="2-Random-reboot"><a href="#2-Random-reboot" class="headerlink" title="2. Random reboot"></a>2. Random reboot</h3><p>这种情况就是系统出错导致的重启。可以按一下四种情况去诊断其重启原因。<br>一般分为两个层面的重启，一种是hard reboot，一般是kernel 或者 radio-level的错误导致重启；另一种是在kernel正常运行的情况下Android runtime的重启，可能是由Deadlock，System server process crash或native crash导致的。</p><h4 id="2-1-Kernel-panic"><a href="#2-1-Kernel-panic" class="headerlink" title="2.1 Kernel panic"></a>2.1 Kernel panic</h4><p>诊断是否有kernel panic， 可以check kernel logs里是否有如下log<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[  424.909515] Kernel panic - not syncing: Fatal exception</span><br><span class="line">[  424.909606] Backtrace: </span><br><span class="line">[  424.909790] [&lt;c005a5ec&gt;] (dump_backtrace+0x0/0x10c) from [&lt;c05f38dc&gt;] (dump_stack+0x18/0x1c)</span><br><span class="line">[  424.909973]  r6:c5cccf00 r5:00000000 r4:c08505a0 r3:00000000</span><br></pre></td></tr></table></figure></p><h4 id="2-2-Radio-side-problem"><a href="#2-2-Radio-side-problem" class="headerlink" title="2.2 Radio-side problem"></a>2.2 Radio-side problem</h4><p>Radio level的错误可以查看LAST_KMSG中是否有如下log<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[  535.383270] ARM9 has CRASHED</span><br><span class="line">[  535.383666] smem: DIAG &apos;MOD SM-TM   00000</span><br></pre></td></tr></table></figure></p><h4 id="2-3-Deadlock"><a href="#2-3-Deadlock" class="headerlink" title="2.3 Deadlock"></a>2.3 Deadlock</h4><p>死锁的error log如下，可以从EVENT_LOG或者SYSTEM_LOG中查找。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">04-04 14:06:16.888   885  1089 W Watchdog: *** WATCHDOG KILLING SYSTEM PROCESS: null</span><br></pre></td></tr></table></figure></p><h4 id="2-4-System-server-process-crash"><a href="#2-4-System-server-process-crash" class="headerlink" title="2.4 System server process crash"></a>2.4 System server process crash</h4><p>log如下，也是从EVENT_LOG或者SYSTEM_LOG中查找。关键字：<br>*** FATAL EXCEPTION IN SYSTEM PROCESS</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">01-01 12:45:11.950 E/AndroidRuntime( 4429): *** FATAL EXCEPTION IN SYSTEM PROCESS: main</span><br></pre></td></tr></table></figure><h4 id="2-5-Native-crash"><a href="#2-5-Native-crash" class="headerlink" title="2.5 Native crash"></a>2.5 Native crash</h4><p>Native crash的log都是从一行星号开始, 可以作为标志去SYSTEM_LOG中查找。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">07-28 11:31:21.675: INFO/DEBUG(2880): *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***</span><br><span class="line">07-28 11:31:21.675: INFO/DEBUG(2880): Build fingerprint: &apos;verizon/voles/sholes/sholes:2.2.2/FRG83G/91102:user/release-keys&apos;</span><br><span class="line">07-28 11:31:21.675: INFO/DEBUG(2880): pid: 2893, tid: 2894  &gt;&gt;&gt; com.gnychis.coexisyst &lt;&lt;&lt;</span><br><span class="line">07-28 11:31:21.675: INFO/DEBUG(2880): signal 11 (SIGSEGV), fault addr 2d4eedb4</span><br><span class="line">07-28 11:31:21.675: INFO/DEBUG(2880):  r0 2d4eeda4  r1 00000000  r2 00000024  r3 00000000</span><br><span class="line">07-28 11:31:21.675: INFO/DEBUG(2880):  r4 00d3e770  r5 00000000  r6 4184ff98  r7 4184ffa4</span><br><span class="line">07-28 11:31:21.675: INFO/DEBUG(2880):  r8 100ffad0  r9 4184ff9c  10 4184ff84  fp 100ffe30</span><br><span class="line">07-28 11:31:21.675: INFO/DEBUG(2880):  ip 85b7efec  sp 100ffa88  lr 845d13f8  pc 845f8c38  cpsr 60000010</span><br><span class="line">07-28 11:31:21.675: INFO/DEBUG(2880):  d0  6472656767756265  d1  4472fb3844714069</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;解析bugreport，根据不同的log分析Android重启的原因&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1-Normal-reset&quot;&gt;&lt;a href=&quot;#1-Normal-reset&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="Android" scheme="http://lynettez.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>Analyze the Process of Setting KL for Physical Keyboard</title>
    <link href="http://lynettez.github.io/2018/07/15/Analyze-the-Process-of-Setting-KeyboardLayout-for-Physical-Keyboard/"/>
    <id>http://lynettez.github.io/2018/07/15/Analyze-the-Process-of-Setting-KeyboardLayout-for-Physical-Keyboard/</id>
    <published>2018-07-15T08:19:24.000Z</published>
    <updated>2018-07-25T07:44:22.866Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>基于Android 8.0源码，分析InputManagerService给Physical Keyboard 设置Keyboard Layout(KL)的具体过程。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">frameworks/<span class="keyword">native</span>/services/inputflinger/</span><br><span class="line">  - InputDispatcher.cpp</span><br><span class="line">  - InputReader.cpp</span><br><span class="line">  - InputManager.cpp</span><br><span class="line">  - EventHub.cpp</span><br><span class="line">  - InputListener.cpp</span><br><span class="line"></span><br><span class="line">frameworks/<span class="keyword">native</span>/libs/input/</span><br><span class="line">  - InputTransport.cpp</span><br><span class="line">  - Input.cpp</span><br><span class="line">  - InputDevice.cpp</span><br><span class="line">  - Keyboard.cpp</span><br><span class="line">  - KeyCharacterMap.cpp</span><br><span class="line">  - IInputFlinger.cpp</span><br><span class="line"></span><br><span class="line">frameworks/base/services/core/</span><br><span class="line">  - java/com/android/server/input/InputManagerService.java</span><br><span class="line">  - java/com/android/server/input/PersistentDataStore.java</span><br><span class="line">  - jni/com_android_server_input_InputManagerService.cpp</span><br><span class="line"></span><br><span class="line">frameworks/base/packages/InputDevices/</span><br><span class="line">  - src/com/android/inputdevices/InputDeviceReceiver.java</span><br><span class="line">  - res/xml/keyboard_layouts.xml</span><br><span class="line">  - res/raw/...</span><br></pre></td></tr></table></figure><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p><a href="http://gityuan.com/2016/12/10/input-manager/" target="_blank" rel="noopener">Gityuan博客</a>有详细分析Input系统，从该博客可以学习到Input模块的工作原理， 以及主要组成：</p><ul><li>Native层的InputReader负责从EventHub取出事件并处理，再交给InputDispatcher</li><li>Native层的InputDispatcher接收来自InputReader的输入事件，并记录WMS的窗口信息，用于派发事件到合适的窗口</li><li>Java层的InputManagerService跟WMS交互，WMS记录所有窗口信息，并同步更新到IMS，为InputDispatcher正确派发事件到ViewRootImpl提供保障</li></ul><p>当Physical Keyboard(后面会直接用PK代替) 通过USB与Android设备连接时，首先触发的是硬件驱动，UsbHostManager 识别PK并发出USB_DEVICE_ATTACHED广播, EventHub通过InputReader线程会循环读取消息并调用getEvents()读取输入事件。<br>调用的流程是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventHub::getEvents -&gt; EventHub::scanDevicesLocked -&gt; EventHub::scanDirLocked -&gt; EventHub::openDeviceLocked</span><br></pre></td></tr></table></figure></p><p>查看openDeviceLocked方法，可以知道此方法首先打开devicePath，然后new Device，调用LoadKeyMapLocked()来给PK load相应的.kl和.kcm, 所有的.kl文件和.kcm文件都放在/framework/base/data/keyboards/下面。我们可以看到有许多Vendor_XXXX_PRODUCT_XXXX命名的.kl和.kcm file，在loadKeymap时就是根据Device的vendor， product值来查找有没有相对应的Vendor_XXXX_PRODUCT_XXXX文件。多数情况下都不会有与PK对应的.kl和.kcm文件，这时Input系统会load默认的Generic.kl和Generic.kcm给该PK (Generic用的是qwerty layout)。</p><p>这也就是为什么有一些法语键盘或者德语键盘链接Android设备之后还是英语的layout的原因。<br>详细的调用流程可以看源码或者是<a href="https://blog.csdn.net/kc58236582/article/details/52199274" target="_blank" rel="noopener">这篇博文https://blog.csdn.net/kc58236582/</a>.</p><p>以上简单介绍了Input系统处理PK连接事件的过程和为其设置.kl和.kcm文件的过程。接下来我将详细介绍一下重新给PK设置Keyboard lauout的过程还有重载新的layout的过程。</p><h2 id="2-为PK重置kl"><a href="#2-为PK重置kl" class="headerlink" title="2. 为PK重置kl"></a>2. 为PK重置kl</h2><p>如上所述，当我们用到非英语键盘时，layout还会加载成qwert的，面对这个问题Input系统已经提供了相应的function供开发者调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/frameworks/base/services/java/com/android/server/input/InputManagerService.java</span><br><span class="line">    @Override</span><br><span class="line">    public void setKeyboardLayoutForInputDevice(InputDeviceIdentifier identifier,</span><br><span class="line">            InputMethodInfo imeInfo, InputMethodSubtype imeSubtype,</span><br><span class="line">            String keyboardLayoutDescriptor) &#123;</span><br><span class="line">        if (!checkCallingPermission(android.Manifest.permission.SET_KEYBOARD_LAYOUT,</span><br><span class="line">                &quot;setKeyboardLayoutForInputDevice()&quot;)) &#123;</span><br><span class="line">            throw new SecurityException(&quot;Requires SET_KEYBOARD_LAYOUT permission&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (keyboardLayoutDescriptor == null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;keyboardLayoutDescriptor must not be null&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (imeInfo == null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;imeInfo must not be null&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        InputMethodSubtypeHandle handle = new InputMethodSubtypeHandle(imeInfo, imeSubtype);</span><br><span class="line">        setKeyboardLayoutForInputDeviceInner(identifier, handle, keyboardLayoutDescriptor);</span><br><span class="line">    &#125;</span><br><span class="line">    private void setKeyboardLayoutForInputDeviceInner(InputDeviceIdentifier identifier,</span><br><span class="line">            InputMethodSubtypeHandle imeHandle, String keyboardLayoutDescriptor) &#123;</span><br><span class="line">        String key = getLayoutDescriptor(identifier);</span><br><span class="line">        synchronized (mDataStore) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (mDataStore.setKeyboardLayout(key, imeHandle, keyboardLayoutDescriptor)) &#123; (见2.2.1)</span><br><span class="line">                    if (DEBUG) &#123;</span><br><span class="line">                        Slog.d(TAG, &quot;Set keyboard layout &quot; + keyboardLayoutDescriptor +</span><br><span class="line">                                &quot; for subtype &quot; + imeHandle + &quot; and device &quot; + identifier +</span><br><span class="line">                                &quot; using key &quot; + key);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (imeHandle.equals(mCurrentImeHandle)) &#123;</span><br><span class="line">                        if (DEBUG) &#123;</span><br><span class="line">                            Slog.d(TAG, &quot;Layout for current subtype changed, switching layout&quot;);</span><br><span class="line">                        &#125;</span><br><span class="line">                        SomeArgs args = SomeArgs.obtain();</span><br><span class="line">                        args.arg1 = identifier;</span><br><span class="line">                        args.arg2 = imeHandle;</span><br><span class="line">                        mHandler.obtainMessage(MSG_SWITCH_KEYBOARD_LAYOUT, args).sendToTarget();（见2.2.3）</span><br><span class="line">                    &#125;</span><br><span class="line">                    mHandler.sendEmptyMessage(MSG_RELOAD_KEYBOARD_LAYOUTS);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                mDataStore.saveIfNeeded();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>此方法被用在<a href="http://androidxref.com/8.0.0_r4/xref/packages/apps/Settings/src/com/android/settings/inputmethod/KeyboardLayoutPickerFragment.java" target="_blank" rel="noopener">Settings/inputmethod</a>里.<br>下面我们分析Input系统是如何在底层运作的。</p><h3 id="2-1-InputDevices"><a href="#2-1-InputDevices" class="headerlink" title="2.1 InputDevices"></a>2.1 InputDevices</h3><h4 id="2-1-1-InputDeviceReceiver"><a href="#2-1-1-InputDeviceReceiver" class="headerlink" title="2.1.1 InputDeviceReceiver"></a>2.1.1 InputDeviceReceiver</h4><p>这个package维护的是一个接收“QUERY_KEYBOARD_LAYOUTS”的BroadcastReceiver。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/src/com/android/inputdevices/InputDeviceReceiver.java</span><br><span class="line">        &lt;receiver android:name=&quot;.InputDeviceReceiver&quot;</span><br><span class="line">                android:label=&quot;@string/keyboard_layouts_label&quot;&gt;</span><br><span class="line">            &lt;intent-filter&gt;</span><br><span class="line">                &lt;action android:name=&quot;android.hardware.input.action.QUERY_KEYBOARD_LAYOUTS&quot; /&gt;</span><br><span class="line">            &lt;/intent-filter&gt;</span><br><span class="line">            &lt;meta-data android:name=&quot;android.hardware.input.metadata.KEYBOARD_LAYOUTS&quot;</span><br><span class="line">                    android:resource=&quot;@xml/keyboard_layouts&quot; /&gt;</span><br><span class="line">        &lt;/receiver&gt;</span><br></pre></td></tr></table></figure></p><h4 id="2-1-2-Keyboardlayouts"><a href="#2-1-2-Keyboardlayouts" class="headerlink" title="2.1.2 Keyboardlayouts"></a>2.1.2 Keyboardlayouts</h4><p>这里还存放了重要的/res/xml/keyboardlayouts.xml 和 /res/raw/…kcm, /res/raw/下存放了所有语言的.kcm files. xml文件是map所有.kcm文件用的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;keyboard-layouts xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line">    &lt;keyboard-layout android:name=&quot;keyboard_layout_english_uk&quot;</span><br><span class="line">            android:label=&quot;@string/keyboard_layout_english_uk_label&quot;</span><br><span class="line">            android:keyboardLayout=&quot;@raw/keyboard_layout_english_uk&quot; /&gt;</span><br><span class="line">...</span><br><span class="line">    &lt;keyboard-layout android:name=&quot;keyboard_layout_latvian&quot;</span><br><span class="line">            android:label=&quot;@string/keyboard_layout_latvian&quot;</span><br><span class="line">            android:keyboardLayout=&quot;@raw/keyboard_layout_latvian_qwerty&quot; /&gt;</span><br><span class="line">&lt;/keyboard-layouts&gt;</span><br></pre></td></tr></table></figure></p><h3 id="2-2-InputManagerService"><a href="#2-2-InputManagerService" class="headerlink" title="2.2 InputManagerService"></a>2.2 InputManagerService</h3><p>此章节将介绍IMS中重要的方法和相应的Class。</p><h4 id="2-2-1-PersistentDataStore"><a href="#2-2-1-PersistentDataStore" class="headerlink" title="2.2.1 PersistentDataStore"></a>2.2.1 PersistentDataStore</h4><p>IMS通过PersistentDataStore来存储所有的Input devices的信息。在/data/system/input-manager-state.xml中。<br>通过adb可以查看该文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/data/system # cat input-manager-state.xml                                                                                                                      &lt;?xml version=&apos;1.0&apos; encoding=&apos;utf-8&apos; standalone=&apos;yes&apos; ?&gt;</span><br><span class="line">&lt;input-manager-state&gt;</span><br><span class="line">    &lt;input-devices&gt;</span><br><span class="line">        &lt;input-device descriptor=&quot;vendor:16700,product:8467&quot;&gt;</span><br><span class="line">            &lt;keyboard-layout descriptor=&quot;com.android.inputdevices/com.android.inputdevices.InputDeviceReceiver/keyboard_layout_french&quot; input-method-id=&quot;com.google.android.inputmethod.latin/com.android.inputmethod.latin.LatinIME&quot; input-method-subtype-id=&quot;843948332&quot; current=&quot;true&quot; /&gt;</span><br><span class="line">        &lt;/input-device&gt;</span><br><span class="line">        &lt;input-device descriptor=&quot;vendor:1266,product:1027&quot;&gt;</span><br><span class="line">            &lt;keyboard-layout descriptor=&quot;com.android.inputdevices/com.android.inputdevices.InputDeviceReceiver/keyboard_layout_french&quot; input-method-id=&quot;com.google.android.inputmethod.latin/com.android.inputmethod.latin.LatinIME&quot; input-method-subtype-id=&quot;-921088104&quot; current=&quot;true&quot; /&gt;</span><br><span class="line">        &lt;/input-device&gt;</span><br><span class="line">    &lt;/input-devices&gt;</span><br><span class="line">&lt;/input-manager-state&gt;</span><br></pre></td></tr></table></figure></p><p>我们可以看到其中com.android.inputdevices.InputDeviceReceiver/keyboard_layout_french就是对应着2.1.2中的Keyboard-layout name.</p><p>IMS.mDataStore就是PersistentDataStore的实例，以上IMS +1391行code就是在set相应的layout值。</p><h4 id="2-2-2-visitAllKeyboardLayouts"><a href="#2-2-2-visitAllKeyboardLayouts" class="headerlink" title="2.2.2 visitAllKeyboardLayouts()"></a>2.2.2 visitAllKeyboardLayouts()</h4><p>这个方法会被native层用到，之后的篇幅会介绍到。此方法主要功能就是遍历2.1.2中的keyboardlayouts.xml维护的所有的layouts。<br>还有另外一个方法是visitKeyboardLayout()会被Settings.getKeyboardLayout()用到，原理也是一样的，遍历xml找到相应的layout。<br>具体实现是如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void visitAllKeyboardLayouts(KeyboardLayoutVisitor visitor) &#123;</span><br><span class="line">    final PackageManager pm = mContext.getPackageManager();</span><br><span class="line">    Intent intent = new Intent(InputManager.ACTION_QUERY_KEYBOARD_LAYOUTS);</span><br><span class="line">    for (ResolveInfo resolveInfo : pm.queryBroadcastReceivers(intent,</span><br><span class="line">            PackageManager.GET_META_DATA | PackageManager.MATCH_DIRECT_BOOT_AWARE</span><br><span class="line">                    | PackageManager.MATCH_DIRECT_BOOT_UNAWARE)) &#123;</span><br><span class="line">        final ActivityInfo activityInfo = resolveInfo.activityInfo;</span><br><span class="line">        final int priority = resolveInfo.priority;</span><br><span class="line">        visitKeyboardLayoutsInPackage(pm, activityInfo, null, priority, visitor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中InputManager.ACTION_QUERY_KEYBOARD_LAYOUTS 就是2.1.1中的QUERY_KEYBOARD_LAYOUTS。</p><h4 id="2-2-3-handleSwithKeyboardLayout"><a href="#2-2-3-handleSwithKeyboardLayout" class="headerlink" title="2.2.3 handleSwithKeyboardLayout"></a>2.2.3 handleSwithKeyboardLayout</h4><p>此方法就是handle IMS +1404行的MSG_SWITCH_KEYBOARD_LAYOUT message。它主要做了两件事：</p><ul><li>mDataStore.switchKeyboardLayout, 将input-manager-state.xml更新为之前setKeyboardLayout(IMS +1391行)的值。</li><li>reloadKeyboardLayouts() -&gt; nativeReloadKeyboardLayouts() 见2.3.1</li></ul><h3 id="2-3-Native-InputManager"><a href="#2-3-Native-InputManager" class="headerlink" title="2.3 Native InputManager"></a>2.3 Native InputManager</h3><h4 id="2-3-1-nativeReloadKeyboardLayouts"><a href="#2-3-1-nativeReloadKeyboardLayouts" class="headerlink" title="2.3.1 nativeReloadKeyboardLayouts"></a>2.3.1 nativeReloadKeyboardLayouts</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp</span><br><span class="line">static void nativeReloadKeyboardLayouts(JNIEnv* /* env */,</span><br><span class="line">        jclass /* clazz */, jlong ptr) &#123;</span><br><span class="line">    NativeInputManager* im = reinterpret_cast&lt;NativeInputManager*&gt;(ptr);</span><br><span class="line"></span><br><span class="line">    im-&gt;getInputManager()-&gt;getReader()-&gt;requestRefreshConfiguration(</span><br><span class="line">            InputReaderConfiguration::CHANGE_KEYBOARD_LAYOUTS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要工作是trigger InputReader::requestRefreshConfiguration()</p><h4 id="2-3-2-InputReader-cpp"><a href="#2-3-2-InputReader-cpp" class="headerlink" title="2.3.2 InputReader.cpp"></a>2.3.2 InputReader.cpp</h4><p>gityuan的一篇<a href="http://gityuan.com/2016/12/11/input-reader/" target="_blank" rel="noopener">博客</a>中清晰地介绍了InputReader, 对理解下面的代码会很有帮助。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">void InputReader::requestRefreshConfiguration(uint32_t changes) &#123;</span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">    if (changes) &#123;</span><br><span class="line">        bool needWake = !mConfigurationChangesToRefresh;</span><br><span class="line">        mConfigurationChangesToRefresh |= changes;</span><br><span class="line"></span><br><span class="line">        if (needWake) &#123;</span><br><span class="line">            mEventHub-&gt;wake();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">void InputReader::loopOnce() &#123;</span><br><span class="line">    int32_t oldGeneration;</span><br><span class="line">    int32_t timeoutMillis;</span><br><span class="line">    bool inputDevicesChanged = false;</span><br><span class="line">    Vector&lt;InputDeviceInfo&gt; inputDevices;</span><br><span class="line">    &#123; // acquire lock</span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">        oldGeneration = mGeneration;</span><br><span class="line">        timeoutMillis = -1;</span><br><span class="line"></span><br><span class="line">        uint32_t changes = mConfigurationChangesToRefresh;</span><br><span class="line">        if (changes) &#123;</span><br><span class="line">            mConfigurationChangesToRefresh = 0;</span><br><span class="line">            timeoutMillis = 0;</span><br><span class="line">            refreshConfigurationLocked(changes);</span><br><span class="line">        &#125; else if (mNextTimeout != LLONG_MAX) &#123;</span><br><span class="line">            nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);</span><br><span class="line">            timeoutMillis = toMillisecondTimeoutDelay(now, mNextTimeout);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; // release lock</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">void InputReader::refreshConfigurationLocked(uint32_t changes) &#123;</span><br><span class="line">    mPolicy-&gt;getReaderConfiguration(&amp;mConfig);</span><br><span class="line">    mEventHub-&gt;setExcludedDevices(mConfig.excludedDeviceNames);</span><br><span class="line"></span><br><span class="line">    if (changes) &#123;</span><br><span class="line">...</span><br><span class="line">        if (changes &amp; InputReaderConfiguration::CHANGE_MUST_REOPEN) &#123;</span><br><span class="line">            mEventHub-&gt;requestReopenDevices();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (size_t i = 0; i &lt; mDevices.size(); i++) &#123;</span><br><span class="line">                InputDevice* device = mDevices.valueAt(i);</span><br><span class="line">                device-&gt;configure(now, &amp;mConfig, changes);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">void InputDevice::configure(nsecs_t when, const InputReaderConfiguration* config, uint32_t changes) &#123;</span><br><span class="line">...</span><br><span class="line">    if (!isIgnored()) &#123;</span><br><span class="line">        if (!changes) &#123; // first time only</span><br><span class="line">            mContext-&gt;getEventHub()-&gt;getConfiguration(mId, &amp;mConfiguration);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!changes || (changes &amp; InputReaderConfiguration::CHANGE_KEYBOARD_LAYOUTS)) &#123;</span><br><span class="line">            if (!(mClasses &amp; INPUT_DEVICE_CLASS_VIRTUAL)) &#123;</span><br><span class="line">                sp&lt;KeyCharacterMap&gt; keyboardLayout =</span><br><span class="line">                        mContext-&gt;getPolicy()-&gt;getKeyboardLayoutOverlay(mIdentifier); (见2.4)</span><br><span class="line">                if (mContext-&gt;getEventHub()-&gt;setKeyboardLayoutOverlay(mId, keyboardLayout)) &#123;</span><br><span class="line">                    bumpGeneration();（见2.5）</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这部分的代码主要工作是</p><ul><li>把InputReaderConfiguration::CHANGE_KEYBOARD_LAYOUTS换位给<br>mConfigurationChangesToRefresh</li><li>InputReader线程不停的loop，当mConfigurationChangesToRefresh不为0时，调用refreshConfigurationLocked方法</li><li>当changes值不为CHANGE_MUST_REOPEN时，将循环所有的InputDevice，并调用configure方法</li><li>当changes是CHANGE_KEYBOARD_LAYOUTS时 会调用两个重要的方法，将会再下两个小节详细介绍</li></ul><h3 id="2-4-getPolicy"><a href="#2-4-getPolicy" class="headerlink" title="2.4 getPolicy()"></a>2.4 getPolicy()</h3><p>如Gityuan博客中提到的，InputReader的成员变量mPolicy都是指NativeInputManager对象。这里getPolicy()得到的就是NativeInputManager对象。接下来我们看一下getKeyboardLayoutOverlay方法的具体工作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp</span><br><span class="line">public:</span><br><span class="line">    NativeInputManager(jobject contextObj, jobject serviceObj, const sp&lt;Looper&gt;&amp; looper);</span><br><span class="line">...</span><br><span class="line">    /* --- InputReaderPolicyInterface implementation --- */</span><br><span class="line">...</span><br><span class="line">    virtual sp&lt;KeyCharacterMap&gt; getKeyboardLayoutOverlay(const InputDeviceIdentifier&amp; identifier);</span><br><span class="line">...</span><br><span class="line">int register_android_server_InputManager(JNIEnv* env) &#123;</span><br><span class="line">    int res = jniRegisterNativeMethods(env, &quot;com/android/server/input/InputManagerService&quot;,</span><br><span class="line">            gInputManagerMethods, NELEM(gInputManagerMethods));</span><br><span class="line">    (void) res;  // Faked use when LOG_NDEBUG.</span><br><span class="line">    LOG_FATAL_IF(res &lt; 0, &quot;Unable to register native methods.&quot;);</span><br><span class="line"></span><br><span class="line">    // Callbacks</span><br><span class="line"></span><br><span class="line">    jclass clazz;</span><br><span class="line">    FIND_CLASS(clazz, &quot;com/android/server/input/InputManagerService&quot;);</span><br><span class="line">...</span><br><span class="line">    GET_METHOD_ID(gServiceClassInfo.getKeyboardLayoutOverlay, clazz,</span><br><span class="line">            &quot;getKeyboardLayoutOverlay&quot;,</span><br><span class="line">            &quot;(Landroid/hardware/input/InputDeviceIdentifier;)[Ljava/lang/String;&quot;);</span><br></pre></td></tr></table></figure></p><p>主要工作就是通过JNI调用JAVA层的InputManagerService.getKeyboardLayoutOverlay()方法。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">    // Native callback.</span><br><span class="line">    private String[] getKeyboardLayoutOverlay(InputDeviceIdentifier identifier) &#123;</span><br><span class="line">        if (!mSystemReady) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String keyboardLayoutDescriptor = getCurrentKeyboardLayoutForInputDevice(identifier);</span><br><span class="line">        if (keyboardLayoutDescriptor == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final String[] result = new String[2];</span><br><span class="line">        visitKeyboardLayout(keyboardLayoutDescriptor, new KeyboardLayoutVisitor() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void visitKeyboardLayout(Resources resources,</span><br><span class="line">                    int keyboardLayoutResId, KeyboardLayout layout) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    result[0] = layout.getDescriptor();</span><br><span class="line">                    result[1] = Streams.readFully(new InputStreamReader(</span><br><span class="line">                            resources.openRawResource(keyboardLayoutResId)));</span><br><span class="line">                &#125; catch (IOException ex) &#123;</span><br><span class="line">                &#125; catch (NotFoundException ex) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>可以看到它的主要工作是</p><ul><li>从InputDeviceIdentifier中拿到keyboardLayoutDescriptor</li><li>调用visitKeyboardLayout()去遍历kayboardlayouts.xml找到对应的layout resource文件并返回。见2.2.2。</li></ul><h3 id="2-5-EventHub-setKeyboardLayoutOverlay"><a href="#2-5-EventHub-setKeyboardLayoutOverlay" class="headerlink" title="2.5 EventHub::setKeyboardLayoutOverlay()"></a>2.5 EventHub::setKeyboardLayoutOverlay()</h3><p>从2.4节得到的keyboardlayout result作为参数，通过EventHub设置给相应的Device。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">bool EventHub::setKeyboardLayoutOverlay(int32_t deviceId,</span><br><span class="line">        const sp&lt;KeyCharacterMap&gt;&amp; map) &#123;</span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line">    Device* device = getDeviceLocked(deviceId);</span><br><span class="line">    if (device) &#123;</span><br><span class="line">        if (map != device-&gt;overlayKeyMap) &#123;</span><br><span class="line">            device-&gt;overlayKeyMap = map;</span><br><span class="line">            device-&gt;combinedKeyMap = KeyCharacterMap::combine(</span><br><span class="line">                    device-&gt;keyMap.keyCharacterMap, map);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最终实现为PK设置非英语的keyboard layout。</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>Native callback 感觉是最有意思的地方，以后可以用一下，JNI层还是需要多加研究的。对于Input系统，算是通过这次机会了解到这么多细节的东西，但是还有InputDispatch的部分还需要日后仔细学习。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;基于Android 8.0源码，分析InputManagerService给Physical Keyboard 设置Keyboard Layout(KL)的具体过程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlig
      
    
    </summary>
    
      <category term="Android" scheme="http://lynettez.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>Android VTS V8.0</title>
    <link href="http://lynettez.github.io/2018/06/30/Android-VTS-V8-0/"/>
    <id>http://lynettez.github.io/2018/06/30/Android-VTS-V8-0/</id>
    <published>2018-06-30T00:43:45.000Z</published>
    <updated>2018-07-03T02:38:06.993Z</updated>
    
    <content type="html"><![CDATA[<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>Android Vendor Test Suite 包含三部分： VTS， VTS-*， VTI</p><p><em>VTS</em></p><blockquote><p>VTS 是Android Vendor 接口的一致性测试套件， Android Vendor接口即VINTF， 它相应的Object Data 被定义在device manifest 中. Refer to VINTF Object Data Link</p></blockquote><p><em>VTS-</em> *</p><blockquote><p>VTS- 包括可选的非功能测试和测试用例开发工具。<br>VTS 和 VTS- 有一组测试用例， 用于直接在VINTF下测试一下组件：<br>HAL modules，Vendor native libraries(e.g., Vendor NDK. shortly VNDK), OS (i.e., Linux kernel)</p></blockquote><p><em>VTI</em></p><blockquote><p>Vendor Test Infrastructure(VTI) 是一套基于云的基础框架，作用是允许Android设备合作伙伴可以轻松创建一个基于云的持续的VTS测试集成服务。</p></blockquote><hr><h3 id="编译和运行一个VTS-Test-Plan"><a href="#编译和运行一个VTS-Test-Plan" class="headerlink" title="编译和运行一个VTS Test Plan"></a>编译和运行一个VTS Test Plan</h3><p><em>搭建测试环境</em></p><ul><li>64-bit Ubuntu Linux</li><li>Java 8</li><li>Python 2.7</li><li>ADB 1.0.39 adb 一定要 必须要更新 link</li></ul><p>下面下载项，<strong> 一个都不要缺</strong>！！</p><p>Python development kit：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python-dev</span><br></pre></td></tr></table></figure><p>Protocol Buffer tools：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python-protobuf</span><br><span class="line">sudo apt-get install protobuf-compiler</span><br></pre></td></tr></table></figure><p>Python virtual environment-related tools:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python-virtualenv</span><br><span class="line">sudo apt-get install python-pip</span><br></pre></td></tr></table></figure><p>并且要确保linux主机可以用过adb shell 连接到你的Android测试设备</p><p>完成以上工作就可以 编译 VTS 包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">. build/envsetup.sh</span><br><span class="line">lunch aosp_arm64-userdebug</span><br><span class="line">make vts -j</span><br></pre></td></tr></table></figure></p><p>如果你有整套的Android 源码，可以直接croot下运行make vts</p><p>运行 VTS 测试：<br>进入你make出的out 路径并解压，就可以得到一个可执行文件 vts-tradefed。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vts-tradefed</span><br><span class="line">run vts     // where vts is the test plan name</span><br></pre></td></tr></table></figure></p><p>常用的命令：</p><ul><li>run vts //运行默认的vts测试项</li><li>run vts-hal //运行默认的vts hal测试项</li><li>run vts-kernel //运行默认的vts kernel 测试项</li><li>run vts -m &lt;测试模块&gt; //运行特殊的测试模块</li><li>run vts -s &lt;设备串口&gt; //连接多设备时使用</li></ul><p>Windows 下运行VTS测试， 可参考<a href="https://codelabs.developers.google.com/codelabs/android-vts/#1" target="_blank" rel="noopener">Link</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;组成&quot;&gt;&lt;a href=&quot;#组成&quot; class=&quot;headerlink&quot; title=&quot;组成&quot;&gt;&lt;/a&gt;组成&lt;/h3&gt;&lt;p&gt;Android Vendor Test Suite 包含三部分： VTS， VTS-*， VTI&lt;/p&gt;
&lt;p&gt;&lt;em&gt;VTS&lt;/em&gt;&lt;/
      
    
    </summary>
    
      <category term="Android" scheme="http://lynettez.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>冥想练习</title>
    <link href="http://lynettez.github.io/2018/06/30/%E5%86%A5%E6%83%B3%E7%BB%83%E4%B9%A0/"/>
    <id>http://lynettez.github.io/2018/06/30/冥想练习/</id>
    <published>2018-06-30T00:31:21.000Z</published>
    <updated>2018-07-03T02:38:30.008Z</updated>
    
    <content type="html"><![CDATA[<p>Meditate 冥想<br>没有任何宗教的概念，提升幸福感的一种好的方式。</p><hr><p>我们的意识，每天都在不停的思考，做出反应，提出计划，给出判断，还会有不切实际的幻想，对未知未来的联想， 等等… 作为普通人的我们，除了生理疼痛的时候，很少会把意识集中在自己身上，很少去观察现在这个时候的自己。如果我们把感知放大，去感受当下真实发生的让人开心的事情，你就会发现，我们的小确幸才是我们已经得到的真实的宝藏。</p><p>冥想就是让人感受当下真实的美好， 抓住真实的幸福。<br>尝试过冥想的同学一定会感受到，我们的思维真的很难控制，很难专心的感受呼吸，或者专心的去想那根蜡烛，思绪一定会调皮的想着一会吃什么，或者回忆与某人的对话，等等…</p><p>冥想其实也可以让我们练习如何专注于一件事，这就是为什么有些提高注意力的课程会教你如何冥想的原因。个人感觉确实有点效果，真实的体验，之前coding的时候必须要听一些很嗨的rap，越嗨越有劲头，现在真的会觉得吵了… 只好选择一些轻音乐，之前从来都不会听的轻音乐…</p><p>说到这里 想推荐大家 Calm , 有网页版的，也有app。没有特殊需要就不用花钱买课程，用facebook login之后，就可以在首页选择不同的背景，每个动态背景&gt;都配有相应的声音或者轻音乐。比如海浪声，下雨声， 烧柴声，我自己真的超享受。各种ASMR，一定有一个是你自己的ASMR。</p><p>决定要冥想， 但不知道如何正确的冥想，建议先读：<strong> 初学者的冥想书</strong> by Kornfield J. 我是边学习边调整的，相信只要每天坚持就一定有所收获</p><p>下面算是这本书的提炼，主要是把当时觉得很有帮助的point列出来，方便回顾。</p><hr><ul><li>冥想练习有很多种，选择最适合你的，有助于你发展对内心，意识，身体和感受的察觉，才是最好的冥想练习</li><li>作出选择之后，重在坚持，坚持每天冥想，选择你最喜欢的清晨或者傍晚，坚持静坐十五分钟或者你喜欢的时间长短</li><li>所有事物都处在变化的过程中，不妨跟随这种改变，接纳事物的不确定性。在冥想中学者去理解并信任无常的法则</li><li>冥想是为了洞悉生命的法则。在冥想中，我们不断将注意力从奔腾不息的思维和念头上拉回，转而放在身体与感觉之上</li></ul><hr><h3 id="冥想练习之-观呼吸"><a href="#冥想练习之-观呼吸" class="headerlink" title="冥想练习之 观呼吸"></a>冥想练习之 观呼吸</h3><ul><li>首先，找一个你觉得安稳，舒服，放松的姿势，没有压力的坐直，端庄一些，但无需苛求自己</li><li>微微沉肩，让手臂自然下垂，手垂在衣服下摆或膝盖上，保持脊背挺直的同时又能放松</li><li>若哪里不舒服，活动一下也无妨；闭上眼睛，或微微张开 看着地板即可</li><li>将注意力带到此刻，留心周围的环境和声音，去察觉你的身体有什么感受</li><li>观呼吸引导我们察觉呼吸正在发生这一事实，体验自然的呼吸，初期会感觉呼吸变得很紧，很不自然，这很常见，只要放轻松，如果还有紧迫感存在，不妨轻轻松松的面对它</li><li>在静坐初期，心念会如瀑布，你能做的就是，一旦察觉自己陷入思考，计划或回忆中，就给这个念头起个名字“计划”，“回忆”… 并任这个念头离开，回到呼吸上</li><li>要记得心念总是偏离呼吸到别的事情上是非常常见的，不必评判自己这样做不对，只要抹去念头回到呼吸上即可</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Meditate 冥想&lt;br&gt;没有任何宗教的概念，提升幸福感的一种好的方式。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;我们的意识，每天都在不停的思考，做出反应，提出计划，给出判断，还会有不切实际的幻想，对未知未来的联想， 等等… 作为普通人的我们，除了生理疼痛的时候，很少会把意识集中在自己
      
    
    </summary>
    
      <category term="Life Itself" scheme="http://lynettez.github.io/categories/Life-Itself/"/>
    
    
  </entry>
  
  <entry>
    <title>Android HIDL (Java)</title>
    <link href="http://lynettez.github.io/2018/06/18/Android-HIDL-Java/"/>
    <id>http://lynettez.github.io/2018/06/18/Android-HIDL-Java/</id>
    <published>2018-06-18T04:20:33.000Z</published>
    <updated>2018-07-03T02:50:13.862Z</updated>
    
    <content type="html"><![CDATA[<pre><code>HAL接口定义语言或HIDL（发音为“hide-l”）是一种接口描述语言（IDL），用于指定HAL与其用户之间的接口。 它允许指定类型和方法调用，并将其收集到接口和包中。 更广泛地说，HIDL是可以独立编译的代码库之间进行通信的系统。HIDL旨在用于进程间通信（IPC）。</code></pre><p>以上是来自Android官方文档。学习或者尝试使用过HIDL的coder一定都看过<a href="https://source.android.google.cn/devices/architecture/hidl/" target="_blank" rel="noopener">Android HIDL</a>，所以都会了解到，定义了HIDL接口之后，我们可以用C++和JAVA两种方式去写HIDL接口的实现，大多数的HIDL接口都会用C++去写接口的具体实现，并通过.rc文件来start接口服务，这种实现方式很通用，官网和许多博客有具体介绍，如果你需要在native层写接口实现，那可以移步google去搜索一下。</p><p>而JAVA实现方式，一是官网没有特别具体的介绍，二是很少有这种需求也很少有博主用过这种方式，而我在工作中恰好有这样一个需求：  就是要通过HIDL的JAVA实现server端，从而把Android framework的API暴露给native层。<br>经过一番尝试终于实现了需求，所以想要通过这篇博文记录一下自己的收获和实现过程中遇到的问题。</p><hr><h3 id="定义接口文件"><a href="#定义接口文件" class="headerlink" title="定义接口文件"></a>定义接口文件</h3><p>首先根据官方文档提供的格式写好自己的.hal接口文件，并通过hild-gen生成相应的Android.bp 和 Android.mk文件。<br>两个文件会相应build出很重要的C++和JAVA的Shared Library，这两个库是供服务端和客户算使用的。</p><ul><li>这里我曾遇到的问题是Android.bp有问题，build不出相应的C++的Shared Library。<ul><li>解决办法是修改/interfaces/下面的所有Android.bp，确保他们都加了你的新接口的路径（eg. myinterface/1.0），只要有一层缺了该路径，就会导致build不出你要的C++ Library.</li></ul></li></ul><p>如果运行hile-gen时，显示error找不到command， 需要先在/system/tools/下 运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m hidl-gen</span><br></pre></td></tr></table></figure><hr><h3 id="JAVA-接口的实现"><a href="#JAVA-接口的实现" class="headerlink" title="JAVA 接口的实现"></a>JAVA 接口的实现</h3><p>用JAVA实现接口，有点类似于AIDL的借口实现，我们需要实现一个服务端apk，并在Android开机启动时保证成功调起接口的服务，以便各个客户端使用。</p><ul><li>首先有了相应的.bp和.mk文件，就可以得到相应的C++ 和 JAVA的Library，我们需要在JAVA server apk 的makefile 中引入Java library，</li><li><p>其次，server端必须要有一个一直在运行的进程在，所以我们需要一个activity或者service进程来承载整个server端，并且需要在监听到开机广播后启用它，并完成工作：registerAsService() //让我们定义的接口的HwService注册到HwServiceManager中</p><ul><li><p>类似于AIDL，我们同样需要实现类MyInterface extends IMyInterface.Stub，之后Override所有接口方法并实现具体的function。下面是registerAsService()具体例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyInterface testService = <span class="keyword">new</span> MyInterface();</span><br><span class="line">testService.registerAsService(<span class="string">"MyTestService"</span>);</span><br></pre></td></tr></table></figure></li><li><p>这里遇到过的问题是Service注册之后 client端偶尔会得到空的Service。因为当时只是试验，所以就随意的在service.onStartCommand()中加了上面两行代码。 解决办法就是要把MyInterface的对象作为Service的成员变量，这样就不会偶尔被回收了…</p></li></ul></li><li><p>第三，修改 DEVICE MANIFEST 和 SELINUX POLICY。只有修改过这两项，你的service才允许被注册到HwServiceManager中。Device Manifest 可以参考 <a href="https://source.android.google.cn/devices/architecture/vintf/objects" target="_blank" rel="noopener">VINTF Object Data Link</a>用相同的格式声明你自己的接口。如果你用C++实现server端这一条同样需要被执。</p><ul><li>关于SELinux 就不具体介绍了，可以根据相应的SELinux denial logs来修改你的SELinux policy。在这之前可以用下面的命令行跳过SELinux 的拦截。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell setenforce 0</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h3 id="CLIENT-端测试"><a href="#CLIENT-端测试" class="headerlink" title="CLIENT 端测试"></a>CLIENT 端测试</h3><p>Client端不区分JAVA实现的还是C++实现的接口。Client端实现很简单，算是HIDL的优点之一，只要调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IMyInterface.getService(<span class="string">"MyTestService"</span>) <span class="comment">//JAVA</span></span><br><span class="line">IMyInterface::getService(<span class="string">"MyTestService"</span>) <span class="comment">//C++</span></span><br></pre></td></tr></table></figure><p>JAVA Client端同时也需要引用JAVA Library。如果有相应的Callback， 需要像AIDL一样在Client端有一个Callback类 extends ICallback.Stub.</p><p>C++ 的Client端 同样的需要加C++的Shared Library.</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过HIDL JAVA server端封装某些framework API，native层就可以通过HIDL接口调用相应的方法，从而调用到framework API了，除了缩短升级时间的优点，就这一个功能也是非常有用的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;HAL接口定义语言或HIDL（发音为“hide-l”）是一种接口描述语言（IDL），用于指定HAL与其用户之间的接口。 它允许指定类型和方法调用，并将其收集到接口和包中。 更广泛地说，HIDL是可以独立编译的代码库之间进行通信的系统。
HIDL旨在用于进程间
      
    
    </summary>
    
      <category term="Android" scheme="http://lynettez.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>Start with Hexo</title>
    <link href="http://lynettez.github.io/2018/06/18/Start-with-Hexo/"/>
    <id>http://lynettez.github.io/2018/06/18/Start-with-Hexo/</id>
    <published>2018-06-18T03:12:25.000Z</published>
    <updated>2018-06-18T04:16:16.762Z</updated>
    
    <content type="html"><![CDATA[<p>Some links which could help us to create our own site:</p><p><a href="https://guides.github.com/features/pages/" target="_blank" rel="noopener">How to creat your GitHub Pages</a></p><p><a href="https://hexo.io/zh-tw/docs/index.html" target="_blank" rel="noopener">Hexo Guide</a></p><p><a href="https://www.jianshu.com/p/21d80d5bfca1" target="_blank" rel="noopener">Hexo deployer to your GitHub Pages</a></p><p><a href="https://wizardforcel.gitbooks.io/markdown-simple-world/1.html" target="_blank" rel="noopener">Markdown 编辑器推荐</a></p><p><a href="https://www.jianshu.com/p/c4f65ebe23ad" target="_blank" rel="noopener">Add Disqus comments in Hexo</a></p><hr><p>Commonly used commands:</p><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;My New Post&quot;</span><br></pre></td></tr></table></figure><p>More info: New a post and need you to modify the .md file</p><h3 id="Clean-project"><a href="#Clean-project" class="headerlink" title="Clean project"></a>Clean project</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure><p>More info: Clean some files which was generated by the last operate</p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><p>More info: Generating</p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>More info: test in local</p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>Don’t forget to fork your repo after hexo d</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Some links which could help us to create our own site:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://guides.github.com/features/pages/&quot; target=&quot;_blank&quot; rel=&quot;no
      
    
    </summary>
    
      <category term="Hexo" scheme="http://lynettez.github.io/categories/Hexo/"/>
    
    
  </entry>
  
</feed>
